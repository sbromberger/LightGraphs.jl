<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path and Traversal · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="graphtypes.html">Choosing A Graph Type</a></li><li><a class="toctext" href="types.html">LightGraphs Types</a></li><li><a class="toctext" href="basicproperties.html">Accessing Properties</a></li><li><a class="toctext" href="generators.html">Making and Modifying Graphs</a></li><li><a class="toctext" href="persistence.html">Reading / Writing Graphs</a></li><li><a class="toctext" href="operators.html">Operators</a></li><li><a class="toctext" href="plotting.html">Plotting Graphs</a></li><li class="current"><a class="toctext" href="pathing.html">Path and Traversal</a><ul class="internal"><li><a class="toctext" href="#Graph-Traversal-1">Graph Traversal</a></li><li><a class="toctext" href="#Random-walks-1">Random walks</a></li><li><a class="toctext" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></li><li><a class="toctext" href="#Cycle-Detection-1">Cycle Detection</a></li><li><a class="toctext" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></li><li><a class="toctext" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></li><li><a class="toctext" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></li></ul></li><li><a class="toctext" href="distance.html">Distance</a></li><li><a class="toctext" href="centrality.html">Centrality Measures</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="matching.html">Matching</a></li><li><a class="toctext" href="community.html">Community Structures</a></li><li><a class="toctext" href="degeneracy.html">Degeneracy</a></li><li><a class="toctext" href="integration.html">Integration with other packages</a></li><li><a class="toctext" href="experimental.html">Experimental Functionality</a></li><li><a class="toctext" href="parallel.html">Parallel Algorithms</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="developing.html">Developer Notes</a></li><li><a class="toctext" href="license.html">License Information</a></li><li><a class="toctext" href="citing.html">Citing LightGraphs</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="pathing.html">Path and Traversal</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/master/docs/src/pathing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Path and Traversal</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-and-Traversal-1" href="#Path-and-Traversal-1">Path and Traversal</a></h1><p><em>LightGraphs.jl</em> provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.</p><p>Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by <code>[src,dst]</code> vertices. That is, <code>distmx[2,4] = 2.5</code> assigns the distance <code>2.5</code> to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs <code>distmx[4,2]</code> has to be set.</p><p>Default edge distances may be passed in via the</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DefaultDistance" href="#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultDistance</code></pre><p>An array-like structure that provides distance values of <code>1</code> for any <code>src, dst</code> combination.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/distance.jl#L3-L7">source</a></section><p>structure.</p><p>Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,</p><ol><li>distance values for undefined edges will be ignored, and</li><li>any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.</li><li>any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.</li></ol><h2><a class="nav-anchor" id="Graph-Traversal-1" href="#Graph-Traversal-1">Graph Traversal</a></h2><p><em>Graph traversal</em> refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:</p><ul><li><code>BreadthFirst</code>,</li><li><code>DepthFirst</code>, and</li><li><code>MaximumAdjacency</code>.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_tree" href="#LightGraphs.bfs_tree"><code>LightGraphs.bfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bfs.jl#L68-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dfs_tree" href="#LightGraphs.dfs_tree"><code>LightGraphs.dfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acyclic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/dfs.jl#L84-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maximum_adjacency_visit" href="#LightGraphs.maximum_adjacency_visit"><code>LightGraphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maximum_adjacency_visit(g[, distmx][, log][, io])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/maxadjvisit.jl#L73-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_parents" href="#LightGraphs.bfs_parents"><code>LightGraphs.bfs_parents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bfs.jl#L21-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.has_path" href="#LightGraphs.has_path"><code>LightGraphs.has_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bfs.jl#L143-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.diffusion" href="#LightGraphs.diffusion"><code>LightGraphs.diffusion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diffusion(g, p, n)</code></pre><p>Run diffusion simulation on <code>g</code> for <code>n</code> steps with spread probabilities based on <code>p</code>. Return a vector with the set of new vertices reached at each step of the simulation.</p><p><strong>Optional Arguments</strong></p><ul><li><code>initial_infections=sample(vertices(g), 1)</code>: A list of vertices that</li></ul><p>are infected at the start of the simulation.</p><ul><li><code>watch=Vector()</code>: While simulation is always run on the full graph,</li></ul><p>specifying <code>watch</code> limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.</p><ul><li><code>normalize=false</code>: if <code>false</code>, set the probability of spread from a vertex <span>$i$</span> to</li></ul><p>each of the outneighbors of <span>$i$</span> to <span>$p$</span>. If <code>true</code>, set the probability of spread from a vertex <span>$i$</span> to each of the <code>outneighbors</code> of <span>$i$</span> to <span>$\frac{p}{outdegreee(g, i)}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/diffusion.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.diffusion_rate" href="#LightGraphs.diffusion_rate"><code>LightGraphs.diffusion_rate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diffusion_rate(results)
diffusion_rate(g, p, n; ...)</code></pre><p>Given the results of a <code>diffusion</code> output or the parameters to the <code>diffusion</code> simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in <code>watch</code>, if specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/diffusion.jl#L77-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.mincut" href="#LightGraphs.mincut"><code>LightGraphs.mincut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mincut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/maxadjvisit.jl#L11-L18">source</a></section><h2><a class="nav-anchor" id="Random-walks-1" href="#Random-walks-1">Random walks</a></h2><p><em>LightGraphs</em> includes uniform random walks and self avoiding walks:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.randomwalk" href="#LightGraphs.randomwalk"><code>LightGraphs.randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randomwalk(g, s, niter)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/randomwalks.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.non_backtracking_randomwalk" href="#LightGraphs.non_backtracking_randomwalk"><code>LightGraphs.non_backtracking_randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">non_backtracking_randomwalk(g, s, niter)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/randomwalks.jl#L23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.saw" href="#LightGraphs.saw"><code>LightGraphs.saw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">saw(g, s, niter)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/randomwalks.jl#L92-L98">source</a></section><h2><a class="nav-anchor" id="Connectivity-/-Bipartiteness-1" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></h2><p><code>Graph connectivity</code> functions are defined on both undirected and directed graphs:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_connected" href="#LightGraphs.is_connected"><code>LightGraphs.is_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_connected(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is connected. For directed graphs, return <code>true</code> if graph <code>g</code> is weakly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; is_connected(g)
true

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; is_connected(g)
false

julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_connected(g)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L107-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_strongly_connected" href="#LightGraphs.is_strongly_connected"><code>LightGraphs.is_strongly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_strongly_connected(g)</code></pre><p>Return <code>true</code> if directed graph <code>g</code> is strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_strongly_connected(g)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L287-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_weakly_connected" href="#LightGraphs.is_weakly_connected"><code>LightGraphs.is_weakly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_weakly_connected(g)</code></pre><p>Return <code>true</code> if the graph <code>g</code> is weakly connected. If <code>g</code> is undirected, this function is equivalent to <a href="pathing.html#LightGraphs.is_connected"><code>is_connected(g)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_weakly_connected(g)
true

julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; is_connected(g)
true

julia&gt; is_strongly_connected(g)
false

julia&gt; is_weakly_connected(g)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L154-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.connected_components" href="#LightGraphs.connected_components"><code>LightGraphs.connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connected_components(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected components</a> of an undirected graph <code>g</code> as a vector of components, with each element a vector of vertices belonging to the component.</p><p>For directed graphs, see <a href="pathing.html#LightGraphs.strongly_connected_components"><code>strongly_connected_components</code></a> and <a href="pathing.html#LightGraphs.weakly_connected_components"><code>weakly_connected_components</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; connected_components(g)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L74-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.strongly_connected_components" href="#LightGraphs.strongly_connected_components"><code>LightGraphs.strongly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strongly_connected_components(g)</code></pre><p>Compute the strongly connected components of a directed graph <code>g</code>.</p><p>Return an array of arrays, each of which is the entire connected component.</p><p><strong>Implementation Notes</strong></p><p>The order of the components is not part of the API contract.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [3]
 [1, 2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L181-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.weakly_connected_components" href="#LightGraphs.weakly_connected_components"><code>LightGraphs.weakly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weakly_connected_components(g)</code></pre><p>Return the weakly connected components of the graph <code>g</code>. This is equivalent to the connected components of the undirected equivalent of <code>g</code>. For undirected graphs this is equivalent to the <a href="pathing.html#LightGraphs.connected_components"><code>connected_components</code></a> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; weakly_connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L136-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.has_self_loops" href="#LightGraphs.has_self_loops"><code>LightGraphs.has_self_loops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_self_loops(g)</code></pre><p>Return true if <code>g</code> has any self loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; has_self_loops(g)
false

julia&gt; add_edge!(g, 1, 1);

julia&gt; has_self_loops(g)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/core.jl#L320-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.attracting_components" href="#LightGraphs.attracting_components"><code>LightGraphs.attracting_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">attracting_components(g)</code></pre><p>Return a vector of vectors of integers representing lists of attracting components in the directed graph <code>g</code>.</p><p>The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; attracting_components(g)
1-element Array{Array{Int64,1},1}:
 [4, 5]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L381-L404">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_bipartite" href="#LightGraphs.is_bipartite"><code>LightGraphs.is_bipartite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; is_bipartite(g)
true

julia&gt; add_edge!(g, 1, 3);

julia&gt; is_bipartite(g)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bipartition.jl#L67-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bipartite_map" href="#LightGraphs.bipartite_map"><code>LightGraphs.bipartite_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bipartite_map(g) -&gt; Vector{UInt8}</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or <span>$c_i == 2$</span>). If <code>g</code> is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x01
 0x01

julia&gt; add_vertices!(g, 3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x02
 0x01</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bipartition.jl#L1-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.biconnected_components" href="#LightGraphs.biconnected_components"><code>LightGraphs.biconnected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">biconnected_components(g) -&gt; Vector{Vector{Edge{eltype(g)}}}</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">biconnected components</a> of an undirected graph <code>g</code>and return a vector of vectors containing each biconnected component.</p><p>Performance: Time complexity is <span>$\mathcal{O}(|V|)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; biconnected_components(StarGraph(5))
4-element Array{Array{LightGraphs.SimpleGraphs.SimpleEdge,1},1}:
 [Edge 1 =&gt; 3]
 [Edge 1 =&gt; 4]
 [Edge 1 =&gt; 5]
 [Edge 1 =&gt; 2]

julia&gt; biconnected_components(CycleGraph(5))
1-element Array{Array{LightGraphs.SimpleGraphs.SimpleEdge,1},1}:
 [Edge 1 =&gt; 5, Edge 4 =&gt; 5, Edge 3 =&gt; 4, Edge 2 =&gt; 3, Edge 1 =&gt; 2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/biconnectivity/biconnect.jl#L59-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.condensation" href="#LightGraphs.condensation"><code>LightGraphs.condensation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">condensation(g[, scc])</code></pre><p>Return the condensation graph of the strongly connected components <code>scc</code> in the directed graph <code>g</code>. If <code>scc</code> is missing, generate the strongly connected components first.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; foreach(println, edges(condensation(g)))
Edge 2 =&gt; 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L340-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.neighborhood" href="#LightGraphs.neighborhood"><code>LightGraphs.neighborhood</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood(g, v, d, distmx=weights(g))</code></pre><p>Return a vector of each vertex in <code>g</code> at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood(g, 1, 2)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; neighborhood(g, 1, 3)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Int64,1}:
 1
 2
 3
 4
 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L421-L456">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.neighborhood_dists" href="#LightGraphs.neighborhood_dists"><code>LightGraphs.neighborhood_dists</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood_dists(g, v, d, distmx=weights(g))</code></pre><p>Return a a vector of tuples representing each vertex which is at a geodesic distance less than or equal to <code>d</code>, along with its distance from <code>v</code>. Non-negative distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood_dists(g, 1, 3)
4-element Array{Tuple{Int64,Int64},1}:
 (1, 0)
 (2, 1)
 (3, 2)
 (4, 3)

julia&gt; neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Tuple{Int64,Float64},1}:
 (1, 0.0)
 (2, 1.0)
 (3, 2.0)
 (4, 2.25)
 (5, 2.5)

julia&gt; neighborhood_dists(g, 4, 3)
2-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (5, 1)

julia&gt; neighborhood_dists(g, 4, 3, dir=:in)
5-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (3, 1)
 (5, 1)
 (2, 2)
 (1, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L460-L502">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.articulation" href="#LightGraphs.articulation"><code>LightGraphs.articulation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">articulation(g)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">articulation points</a> of a connected graph <code>g</code> and return an array containing all cut vertices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; articulation(StarGraph(5))
1-element Array{Int64,1}:
 1

julia&gt; articulation(PathGraph(5))
3-element Array{Int64,1}:
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/biconnectivity/articulation.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bridges" href="#LightGraphs.bridges"><code>LightGraphs.bridges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bridges(g)</code></pre><p>Compute the <a href="https://en.m.wikipedia.org/wiki/Bridge_(graph_theory)">bridges</a> of a connected graph <code>g</code> and return an array containing all bridges, i.e edges whose deletion increases the number of connected components of the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; bridges(StarGraph(5))
8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 1 =&gt; 5

julia&gt; bridges(PathGraph(5))
8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 4 =&gt; 5
 Edge 3 =&gt; 4
 Edge 2 =&gt; 3
 Edge 1 =&gt; 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/biconnectivity/bridge.jl#L46-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.period" href="#LightGraphs.period"><code>LightGraphs.period</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">period(g)</code></pre><p>Return the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; period(g)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L303-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.isgraphical" href="#LightGraphs.isgraphical"><code>LightGraphs.isgraphical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isgraphical(degs)</code></pre><p>Return true if the degree sequence <code>degs</code> is graphical. A sequence of integers is called graphical, if there exists a graph where the degrees of its vertices form that same sequence.</p><p><strong>Performance</strong></p><p>Time complexity: <span>$\mathcal{O}(|degs|*\log(|degs|))$</span>.</p><p><strong>Implementation Notes</strong></p><p>According to Erdös-Gallai theorem, a degree sequence <span>$\{d_1, ...,d_n\}$</span> (sorted in descending order) is graphic iff the sum of vertex degrees is even and the sequence obeys the property -</p><div>\[\sum_{i=1}^{r} d_i \leq r(r-1) + \sum_{i=r+1}^n min(r,d_i)\]</div><p>for each integer r &lt;= n-1</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/connectivity.jl#L526-L541">source</a></section><h2><a class="nav-anchor" id="Cycle-Detection-1" href="#Cycle-Detection-1">Cycle Detection</a></h2><p>In graph theory, a cycle is defined to be a path that starts from some vertex <code>v</code> and ends up at <code>v</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_cyclic" href="#LightGraphs.is_cyclic"><code>LightGraphs.is_cyclic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/dfs.jl#L4-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maxsimplecycles" href="#LightGraphs.maxsimplecycles"><code>LightGraphs.maxsimplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxsimplecycles(dg::::IsDirected, byscc::Bool = true)</code></pre><p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p><p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter).</p><p><strong>Performance</strong></p><p>A more efficient version is possible.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/johnson.jl#L24-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles" href="#LightGraphs.simplecycles"><code>LightGraphs.simplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles(dg::::IsDirected)</code></pre><p>Compute and return all cycles of the given directed graph using Johnson&#39;s algorithm.</p><p><strong>Performance</strong></p><p>The number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <a href="pathing.html#LightGraphs.simplecycles_iter"><code>simplecycles_iter</code></a> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>. If you only need short cycles of a limited length, <a href="pathing.html#LightGraphs.simplecycles_limited_length"><code>simplecycles_limited_length</code></a> can be more efficient.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecycles(CompleteDiGraph(3))
5-element Array{Array{Int64,1},1}:
 [1, 2]
 [1, 2, 3]
 [1, 3]
 [1, 3, 2]
 [2, 3]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/johnson.jl#L160-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_iter" href="#LightGraphs.simplecycles_iter"><code>LightGraphs.simplecycles_iter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_iter(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, up to the ceiling (to avoid memory overload).</p><p><strong>Implementation Notes</strong></p><p>If the graph is small, the ceiling will not be reached and <code>simplecycles(dg::DiGraph)</code> is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p><p>To get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/johnson.jl#L317-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_hawick_james" href="#LightGraphs.simplecycles_hawick_james"><code>LightGraphs.simplecycles_hawick_james</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_hawick_james(g)</code></pre><p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hawick &amp; James.</p><p><strong>References</strong></p><ul><li>Hawick &amp; James, &quot;Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs&quot;, 2008</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/hawick-james.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecyclescount" href="#LightGraphs.simplecyclescount"><code>LightGraphs.simplecyclescount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecyclescount(dg::DiGraph, ceiling = 10^6)</code></pre><p>Count the number of cycles in a directed graph, using Johnson&#39;s algorithm. Return the minimum of the ceiling and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecyclescount(CompleteDiGraph(6))
409</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/johnson.jl#L287-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycleslength" href="#LightGraphs.simplecycleslength"><code>LightGraphs.simplecycleslength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycleslength(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, and return a tuple representing the cycle length and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p>If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecycleslength(CompleteDiGraph(16))
([0, 1, 1, 1, 1, 1, 2, 10, 73, 511, 3066, 15329, 61313, 183939, 367876, 367876], 1000000)

julia&gt; simplecycleslength(WheelDiGraph(16))
([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/johnson.jl#L339-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_limited_length" href="#LightGraphs.simplecycles_limited_length"><code>LightGraphs.simplecycles_limited_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_limited_length(g, n, ceiling=10^6)</code></pre><p>Compute and return at most <code>ceiling</code> cycles of length at most <code>n</code> of the given graph. Both directed and undirected graphs are supported.</p><p><strong>Performance</strong></p><p>The number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, <a href="pathing.html#LightGraphs.simplecycles"><code>simplecycles</code></a> or <a href="pathing.html#LightGraphs.simplecycles_iter"><code>simplecycles_iter</code></a> may be more efficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/limited_length.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.karp_minimum_cycle_mean" href="#LightGraphs.karp_minimum_cycle_mean"><code>LightGraphs.karp_minimum_cycle_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">karp_minimum_cycle_mean(g[, distmx])</code></pre><p>Return minimum cycle mean of the directed graph <code>g</code> with optional edge weights contained in <code>distmx</code>.</p><p><strong>References</strong></p><ul><li><a href="http://dx.doi.org/10.1016/0012-365X(78)90011-0">Karp</a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/cycles/karp.jl#L89-L96">source</a></section><h2><a class="nav-anchor" id="Minimum-Spanning-Trees-(MST)-Algorithms-1" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></h2><p>A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.kruskal_mst" href="#LightGraphs.kruskal_mst"><code>LightGraphs.kruskal_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kruskal_mst(g, distmx=weights(g); minimize=true)</code></pre><p>Return a vector of edges representing the minimum (by default) spanning tree of a connected,  undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal&#39;s algorithm</a>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>minimize=true</code>: if set to <code>false</code>, calculate the maximum spanning tree.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/spanningtrees/kruskal.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.prim_mst" href="#LightGraphs.prim_mst"><code>LightGraphs.prim_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prim_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim&#39;s algorithm</a>. Return a vector of edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/spanningtrees/prim.jl#L1-L7">source</a></section><h2><a class="nav-anchor" id="Shortest-Path-Algorithms-1" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></h2><h3><a class="nav-anchor" id="General-properties-of-shortest-path-algorithms-1" href="#General-properties-of-shortest-path-algorithms-1">General properties of shortest path algorithms</a></h3><ul><li>The distance from a vertex to itself is always <code>0</code>.</li><li>The distance between two vertices with no connecting edge is always <code>Inf</code>.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.a_star" href="#LightGraphs.a_star"><code>LightGraphs.a_star</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="pathing.html#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/astar.jl#L49-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dijkstra_shortest_paths" href="#LightGraphs.dijkstra_shortest_paths"><code>LightGraphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><code>allpaths=false</code>: If true, returns a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that keeps track of all</li></ul><p>predecessors of a given vertex.</p><p><strong>Performance</strong></p><p>If using a sparse matrix for <code>distmx</code>, you <em>may</em> achieve better performance by passing in a transpose of its sparse transpose. That is, assuming <code>D</code> is the sparse distance matrix:</p><pre><code class="language-none">D = transpose(sparse(transpose(D)))</code></pre><p>Be aware that realizing the sparse transpose of <code>D</code> incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to <code>dijkstra_shortest_paths</code> with the distance matrix are planned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; ds = dijkstra_shortest_paths(CycleGraph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = dijkstra_shortest_paths(PathGraph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/dijkstra.jl#L14-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.desopo_pape_shortest_paths" href="#LightGraphs.desopo_pape_shortest_paths"><code>LightGraphs.desopo_pape_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">desopo_pape_shortest_paths(g, src, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>src</code> and all other nodes in graph <code>g</code> using the <a href="http://web.mit.edu/dimitrib/www/SLF.pdf">D&#39;Esopo-Pape algorithm</a>. Return a <a href="pathing.html#LightGraphs.DEsopoPapeState"><code>LightGraphs.DEsopoPapeState</code></a> with relevant traversal information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; ds = desopo_pape_shortest_paths(CycleGraph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = desopo_pape_shortest_paths(PathGraph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/desopo-pape.jl#L11-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bellman_ford_shortest_paths" href="#LightGraphs.bellman_ford_shortest_paths"><code>LightGraphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="pathing.html#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> with relevant traversal information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/bellman-ford.jl#L26-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.floyd_warshall_shortest_paths" href="#LightGraphs.floyd_warshall_shortest_paths"><code>LightGraphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">floyd_warshall_shortest_paths(g, distmx=weights(g))</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="pathing.html#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/floyd-warshall.jl#L13-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.yen_k_shortest_paths" href="#LightGraphs.yen_k_shortest_paths"><code>LightGraphs.yen_k_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen&#39;s algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="pathing.html#LightGraphs.YenState"><code>YenState</code></a> that contains distances and paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/yen.jl#L12-L18">source</a></section><h2><a class="nav-anchor" id="Path-discovery-/-enumeration-1" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances" href="#LightGraphs.gdistances"><code>LightGraphs.gdistances</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bfs.jl#L126-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances!" href="#LightGraphs.gdistances!"><code>LightGraphs.gdistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/traversals/bfs.jl#L78-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.enumerate_paths" href="#LightGraphs.enumerate_paths"><code>LightGraphs.enumerate_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/bellman-ford.jl#L90-L110">source</a></section><h3><a class="nav-anchor" id="Path-States-1" href="#Path-States-1">Path States</a></h3><p>All path states derive from</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.AbstractPathState" href="#LightGraphs.AbstractPathState"><code>LightGraphs.AbstractPathState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPathState</code></pre><p>An abstract type that provides information from shortest paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/core.jl#L1-L5">source</a></section><p>The <code>dijkstra_shortest_paths</code>, <code>floyd_warshall_shortest_paths</code>, <code>bellman_ford_shortest_paths</code>, and <code>yen_shortest_paths</code> functions  return states that contain various  information about the graph learned during traversal. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DijkstraState" href="#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DijkstraState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Dijkstra shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/dijkstra.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DEsopoPapeState" href="#LightGraphs.DEsopoPapeState"><code>LightGraphs.DEsopoPapeState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DEposoPapeState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for D`Esopo-Pape shortest-path calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/desopo-pape.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.BellmanFordState" href="#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BellmanFordState{T, U}</code></pre><p>An <code>AbstractPathState</code> designed for Bellman-Ford shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/bellman-ford.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.FloydWarshallState" href="#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct FloydWarshallState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Floyd-Warshall shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/floyd-warshall.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.YenState" href="#LightGraphs.YenState"><code>LightGraphs.YenState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct YenState{T, U}</code></pre><p>Designed for yen k-shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/c48b2cb8a325706885f652b781fd6a99e6ab2d31/src/shortestpaths/yen.jl#L1-L5">source</a></section><p>The above state types (with the exception of <code>YenState</code>) have the following common information, accessible via the type:</p><p><code>.dists</code> Holds a vector of distances computed, indexed by source vertex.</p><p><code>.parents</code> Holds a vector of parents of each source vertex. The parent of a source vertex is always <code>0</code>.</p><p>(<code>YenState</code> substitutes <code>.paths</code> for <code>.parents</code>.)</p><p>In addition, the following information may be populated with the appropriate arguments to <code>dijkstra_shortest_paths</code>:</p><p><code>.predecessors</code> Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.</p><p><code>.pathcounts</code> Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the <code>.predecessors</code> output above.</p><footer><hr/><a class="previous" href="plotting.html"><span class="direction">Previous</span><span class="title">Plotting Graphs</span></a><a class="next" href="distance.html"><span class="direction">Next</span><span class="title">Distance</span></a></footer></article></body></html>
