<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path and Traversal · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="graphtypes.html">Choosing A Graph Type</a></li><li><a class="toctext" href="types.html">LightGraphs Types</a></li><li><a class="toctext" href="basicproperties.html">Accessing Properties</a></li><li><a class="toctext" href="generators.html">Making and Modifying Graphs</a></li><li><a class="toctext" href="persistence.html">Reading / Writing Graphs</a></li><li><a class="toctext" href="operators.html">Operators</a></li><li><a class="toctext" href="plotting.html">Plotting Graphs</a></li><li class="current"><a class="toctext" href="pathing.html">Path and Traversal</a><ul class="internal"><li><a class="toctext" href="#Graph-Traversal-1">Graph Traversal</a></li><li><a class="toctext" href="#Random-walks-1">Random walks</a></li><li><a class="toctext" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></li><li><a class="toctext" href="#Cycle-Detection-1">Cycle Detection</a></li><li><a class="toctext" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></li><li><a class="toctext" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></li><li><a class="toctext" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></li></ul></li><li><a class="toctext" href="distance.html">Distance</a></li><li><a class="toctext" href="centrality.html">Centrality Measures</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="matching.html">Matching</a></li><li><a class="toctext" href="community.html">Community Structures</a></li><li><a class="toctext" href="degeneracy.html">Degeneracy</a></li><li><a class="toctext" href="integration.html">Integration with other packages</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="developing.html">Developer Notes</a></li><li><a class="toctext" href="license.html">License Information</a></li><li><a class="toctext" href="citing.html">Citing LightGraphs</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="pathing.html">Path and Traversal</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/master/docs/src/pathing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Path and Traversal</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-and-Traversal-1" href="#Path-and-Traversal-1">Path and Traversal</a></h1><p><em>LightGraphs.jl</em> provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.</p><p>Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by <code>[src,dst]</code> vertices. That is, <code>distmx[2,4] = 2.5</code> assigns the distance <code>2.5</code> to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs <code>distmx[4,2]</code> has to be set.</p><p>Default edge distances may be passed in via the</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DefaultDistance" href="#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultDistance</code></pre><p>An array-like structure that provides distance values of <code>1</code> for any <code>src, dst</code> combination.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/distance.jl#L3-L7">source</a></section><p>structure.</p><p>Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,</p><ol><li>distance values for undefined edges will be ignored, and</li><li>any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.</li><li>any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.</li></ol><h2><a class="nav-anchor" id="Graph-Traversal-1" href="#Graph-Traversal-1">Graph Traversal</a></h2><p><em>Graph traversal</em> refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:</p><ul><li><code>BreadthFirst</code>,</li><li><code>DepthFirst</code>, and</li><li><code>MaximumAdjacency</code>.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_tree" href="#LightGraphs.bfs_tree"><code>LightGraphs.bfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/bfs.jl#L68-L75">source</a><div><div><pre><code class="language-none">bfs_tree(LevelSynchronousBFS(), g, s, nv)</code></pre><p>Provide a parallel breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.</p><p><strong>Implementation Notes</strong></p><p>This function uses <code>@threads</code> for parallelism which depends on the <code>JULIA_NUM_THREADS</code> environment variable to decide the number of threads to use. Refer <code>@threads</code> documentation for more details. This function is a high level wrapper around <a href="pathing.html#LightGraphs.bfs_tree!"><code>LightGraphs.bfs_tree!</code></a>; use that function for more performance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/parallel_bfs.jl#L105-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_tree!" href="#LightGraphs.bfs_tree!"><code>LightGraphs.bfs_tree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_tree!(LevelSynchronousBFS(), g, src, parents)</code></pre><p>Provide a parallel breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a parents array. The returned array is an Array of <code>Atomic</code> integers.</p><p><strong>Implementation Notes</strong></p><p>This function uses <code>@threads</code> for parallelism which depends on the <code>JULIA_NUM_THREADS</code> environment variable to decide the number of threads to use. Refer <code>@threads</code> documentation for more details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/parallel_bfs.jl#L77-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dfs_tree" href="#LightGraphs.dfs_tree"><code>LightGraphs.dfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/dfs.jl#L84-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maximum_adjacency_visit" href="#LightGraphs.maximum_adjacency_visit"><code>LightGraphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maximum_adjacency_visit(g[, distmx][, log][, io])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/maxadjvisit.jl#L73-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_parents" href="#LightGraphs.bfs_parents"><code>LightGraphs.bfs_parents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/bfs.jl#L21-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.has_path" href="#LightGraphs.has_path"><code>LightGraphs.has_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/bfs.jl#L143-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.diffusion" href="#LightGraphs.diffusion"><code>LightGraphs.diffusion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diffusion(g, p, n)</code></pre><p>Run diffusion simulation on <code>g</code> for <code>n</code> steps with spread probabilities based on <code>p</code>. Return a vector with the set of new vertices reached at each step of the simulation.</p><p><strong>Optional Arguments</strong></p><ul><li><code>initial_infections=sample(vertices(g), 1)</code>: A list of vertices that</li></ul><p>are infected at the start of the simulation.</p><ul><li><code>watch=Vector()</code>: While simulation is always run on the full graph,</li></ul><p>specifying <code>watch</code> limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.</p><ul><li><code>normalize=false</code>: if <code>false</code>, set the probability of spread from a vertex <span>$i$</span> to</li></ul><p>each of the outneighbors of <span>$i$</span> to <span>$p$</span>. If <code>true</code>, set the probability of spread from a vertex <span>$i$</span> to each of the <code>outneighbors</code> of <span>$i$</span> to <span>$\frac{p}{outdegreee(g, i)}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/diffusion.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.diffusion_rate" href="#LightGraphs.diffusion_rate"><code>LightGraphs.diffusion_rate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diffusion_rate(results)
diffusion_rate(g, p, n; ...)</code></pre><p>Given the results of a <code>diffusion</code> output or the parameters to the <code>diffusion</code> simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in <code>watch</code>, if specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/diffusion.jl#L77-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.mincut" href="#LightGraphs.mincut"><code>LightGraphs.mincut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mincut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/maxadjvisit.jl#L11-L18">source</a></section><h2><a class="nav-anchor" id="Random-walks-1" href="#Random-walks-1">Random walks</a></h2><p><em>LightGraphs</em> includes uniform random walks and self avoiding walks:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.randomwalk" href="#LightGraphs.randomwalk"><code>LightGraphs.randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randomwalk(g, s, niter)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/randomwalks.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.non_backtracking_randomwalk" href="#LightGraphs.non_backtracking_randomwalk"><code>LightGraphs.non_backtracking_randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">non_backtracking_randomwalk(g, s, niter)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/randomwalks.jl#L23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.saw" href="#LightGraphs.saw"><code>LightGraphs.saw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">saw(g, s, niter)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/randomwalks.jl#L92-L97">source</a></section><h2><a class="nav-anchor" id="Connectivity-/-Bipartiteness-1" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></h2><p><code>Graph connectivity</code> functions are defined on both undirected and directed graphs:</p><pre><code class="language-none">is_connected
is_strongly_connected
is_weakly_connected
connected_components
strongly_connected_components
weakly_connected_components
has_self_loops
attracting_components
is_bipartite
bipartite_map
biconnected_components
condensation
neighborhood
neighborhood_dists
articulation
period
isgraphical</code></pre><h2><a class="nav-anchor" id="Cycle-Detection-1" href="#Cycle-Detection-1">Cycle Detection</a></h2><p>In graph theory, a cycle is defined to be a path that starts from some vertex <code>v</code> and ends up at <code>v</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_cyclic" href="#LightGraphs.is_cyclic"><code>LightGraphs.is_cyclic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/dfs.jl#L4-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maxsimplecycles" href="#LightGraphs.maxsimplecycles"><code>LightGraphs.maxsimplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxsimplecycles(dg::::IsDirected, byscc::Bool = true)</code></pre><p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p><p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter). The formula is coming from <a href="Johnson">Johnson, 1973</a>.</p><p><strong>Performance</strong></p><p>A more efficient version is possible.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/johnson.jl#L25-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles" href="#LightGraphs.simplecycles"><code>LightGraphs.simplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles(dg::::IsDirected)</code></pre><p>Compute all cycles of the given directed graph, using <a href="Johnson">Johnson, 1973</a>&#39;s algorithm and return them.</p><p><strong>Performance</strong></p><p>The number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <code>getcycles</code> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/johnson.jl#L157-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_iter" href="#LightGraphs.simplecycles_iter"><code>LightGraphs.simplecycles_iter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_iter(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using <a href="Johnson">Johnson, 1973</a>&#39;s algorithm, up to the ceiling (avoid memory overload).</p><p>If the graph is small, the ceiling will not be reached and <span>$simplecycles(dg::DiGraph)$</span> is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/johnson.jl#L295-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_hadwick_james" href="#LightGraphs.simplecycles_hadwick_james"><code>LightGraphs.simplecycles_hadwick_james</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_hadwick_james(g)</code></pre><p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hadwick &amp; James.</p><p><strong>References</strong></p><ul><li>Hadwick &amp; James, &quot;Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs&quot;, 2008</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/hadwick-james.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecyclescount" href="#LightGraphs.simplecyclescount"><code>LightGraphs.simplecyclescount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecyclescount(dg::DiGraph, ceiling = 10^6)</code></pre><p>Count the number of cycles in a directed graph, using <a href="Johnson">Johnson, 1973</a>&#39;s algorithm.</p><p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p><p>Returns the minimum of the ceiling and the number of cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/johnson.jl#L270-L285">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycleslength" href="#LightGraphs.simplecycleslength"><code>LightGraphs.simplecycleslength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycleslength(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using <a href="Johnson">Johnson, 1973</a>&#39;s algorithm, and return their length.</p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p>It returns <code>cyclelengths</code> and <code>ncycles</code>, the lengths of all cycles and the  number of cycles. The index in the array is the length of the cycle.  If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/johnson.jl#L317-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.karp_minimum_cycle_mean" href="#LightGraphs.karp_minimum_cycle_mean"><code>LightGraphs.karp_minimum_cycle_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">karp_minimum_cycle_mean(g[, distmx])</code></pre><p>Return minimum cycle mean of the directed graph <code>g</code> with optional edge weights contained in <code>distmx</code>.</p><p><strong>References</strong></p><ul><li><a href="http://dx.doi.org/10.1016/0012-365X(78)90011-0">Karp</a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/digraph/cycles/karp.jl#L89-L96">source</a></section><h2><a class="nav-anchor" id="Minimum-Spanning-Trees-(MST)-Algorithms-1" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></h2><p>A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.kruskal_mst" href="#LightGraphs.kruskal_mst"><code>LightGraphs.kruskal_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kruskal_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal&#39;s algorithm</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/spanningtrees/kruskal.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.prim_mst" href="#LightGraphs.prim_mst"><code>LightGraphs.prim_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prim_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim&#39;s algorithm</a>. Return a vector of edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/spanningtrees/prim.jl#L8-L14">source</a></section><h2><a class="nav-anchor" id="Shortest-Path-Algorithms-1" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></h2><h3><a class="nav-anchor" id="General-properties-of-shortest-path-algorithms-1" href="#General-properties-of-shortest-path-algorithms-1">General properties of shortest path algorithms</a></h3><ul><li>The distance from a vertex to itself is always <code>0</code>.</li><li>The distance between two vertices with no connecting edge is always <code>Inf</code>.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.a_star" href="#LightGraphs.a_star"><code>LightGraphs.a_star</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="pathing.html#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/astar.jl#L36-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dijkstra_shortest_paths" href="#LightGraphs.dijkstra_shortest_paths"><code>LightGraphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><code>allpaths=false</code>: If true, returns a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that keeps track of all</li></ul><p>predecessors of a given vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/dijkstra.jl#L14-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bellman_ford_shortest_paths" href="#LightGraphs.bellman_ford_shortest_paths"><code>LightGraphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="pathing.html#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> with relevant traversal information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/bellman-ford.jl#L58-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.floyd_warshall_shortest_paths" href="#LightGraphs.floyd_warshall_shortest_paths"><code>LightGraphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">floyd_warshall_shortest_paths(g, distmx=weights(g); parallel=false)</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="pathing.html#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>parallel=false</code>: If true, the algorithm runs in parallel.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/floyd-warshall.jl#L126-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.yen_k_shortest_paths" href="#LightGraphs.yen_k_shortest_paths"><code>LightGraphs.yen_k_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen&#39;s algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="pathing.html#LightGraphs.YenState"><code>YenState</code></a> that contains distances and paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/yen.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.parallel_multisource_dijkstra_shortest_paths" href="#LightGraphs.parallel_multisource_dijkstra_shortest_paths"><code>LightGraphs.parallel_multisource_dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parallel_multisource_dijkstra_shortest_paths(g, sources=vertices(g), distmx=weights(g))</code></pre><p>Compute the shortest paths between all pairs of vertices in graph <code>g</code> by running [<code>dijkstra_shortest_paths</code>] for every vertex and using an optional list of source vertex <code>sources</code> and an optional distance matrix <code>distmx</code>. Return a <a href="@ref"><code>MultipleDijkstraState</code></a> with relevant traversal information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/dijkstra.jl#L122-L129">source</a></section><h2><a class="nav-anchor" id="Path-discovery-/-enumeration-1" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances" href="#LightGraphs.gdistances"><code>LightGraphs.gdistances</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/bfs.jl#L126-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances!" href="#LightGraphs.gdistances!"><code>LightGraphs.gdistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/traversals/bfs.jl#L78-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.enumerate_paths" href="#LightGraphs.enumerate_paths"><code>LightGraphs.enumerate_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/bellman-ford.jl#L116-L135">source</a></section><h3><a class="nav-anchor" id="Path-States-1" href="#Path-States-1">Path States</a></h3><p>All path states derive from</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.AbstractPathState" href="#LightGraphs.AbstractPathState"><code>LightGraphs.AbstractPathState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPathState</code></pre><p>An abstract type that provides information from shortest paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/core.jl#L1-L5">source</a></section><p>The <code>dijkstra_shortest_paths</code>, <code>floyd_warshall_shortest_paths</code>, <code>bellman_ford_shortest_paths</code>, and <code>yen_shortest_paths</code> functions  return states that contain various  information about the graph learned during traversal. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DijkstraState" href="#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DijkstraState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Dijkstra shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/dijkstra.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.BellmanFordState" href="#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BellmanFordState{T, U}</code></pre><p>An <code>AbstractPathState</code> designed for Bellman-Ford shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/bellman-ford.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.FloydWarshallState" href="#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct FloydWarshallState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Floyd-Warshall shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/floyd-warshall.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.YenState" href="#LightGraphs.YenState"><code>LightGraphs.YenState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct YenState{T, U}</code></pre><p>Designed for yen k-shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/05c9caaf5f15db43de6c2d70218272c03918c727/src/shortestpaths/yen.jl#L1-L5">source</a></section><p>The above state types (with the exception of <code>YenState</code>) have the following common information, accessible via the type:</p><p><code>.dists</code> Holds a vector of distances computed, indexed by source vertex.</p><p><code>.parents</code> Holds a vector of parents of each source vertex. The parent of a source vertex is always <code>0</code>.</p><p>(<code>YenState</code> substitutes <code>.paths</code> for <code>.parents</code>.)</p><p>In addition, the following information may be populated with the appropriate arguments to <code>dijkstra_shortest_paths</code>:</p><p><code>.predecessors</code> Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.</p><p><code>.pathcounts</code> Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the <code>.predecessors</code> output above.</p><footer><hr/><a class="previous" href="plotting.html"><span class="direction">Previous</span><span class="title">Plotting Graphs</span></a><a class="next" href="distance.html"><span class="direction">Next</span><span class="title">Distance</span></a></footer></article></body></html>
