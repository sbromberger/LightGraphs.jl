<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->
*LightGraphs.jl* provides several traversal and shortest-path algorithms, along with
various utility functions. Where appropriate, edge distances may be passed in as a
matrix of real number values. The matrix should be indexed by `[src, dst]` (see [Getting Started](gettingstarted.html) for more information).

## Graph Traversal

*Graph traversal* refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:

* `BreadthFirst`,
* `DepthFirst`, and
* `MaximumAdjacency`.
### bfs_tree
```
bfs_tree(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64)
```
Provides a breadth-first traversal of the graph `g` starting with source vertex `s`, and returns a directed acyclic graph of vertices in the order they were discovered.

This function is a high level wrapper around bfs_tree!, use that function for more performance.

### dfs_tree
```
dfs_tree(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64)
```
Provides a depth-first traversal of the graph `g` starting with source vertex `s`, and returns a directed acyclic graph of vertices in the order they were discovered.

## Random walks
*LightGraphs* includes uniform random walks and self avoiding walks:
### randomwalk
```
randomwalk(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Integer, niter::Integer)
```
Performs a random walk on graph `g` starting at vertex `s` and continuing for a maximum of `niter` steps. Returns a vector of vertices visited in order.

### saw
```
saw(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Integer, niter::Integer)
```
Performs a [self-avoiding walk](https://en.wikipedia.org/wiki/Self-avoiding_walk) on graph `g` starting at vertex `s` and continuing for a maximum of `niter` steps. Returns a vector of vertices visited in order.

## Connectivity / Bipartiteness
`Graph connectivity` functions are defined on both undirected and directed graphs:
### is_connected
```
is_connected(g::LightGraphs.Graph)
is_connected(g::LightGraphs.DiGraph)
```
Returns `true` if `g` is connected. For DiGraphs, this is equivalent to a test of weak connectivity.

### is_strongly_connected
```
is_strongly_connected(g::LightGraphs.DiGraph)
```
Returns `true` if `g` is (strongly) connected.

### is_weakly_connected
```
is_weakly_connected(g::LightGraphs.DiGraph)
```
Returns `true` if the undirected graph of `g` is connected.

### connected_components
```
connected_components(g)
```
Returns the [connected components](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)) of an undirected graph `g` as a vector of components, each represented by a vector of vectors of vertices belonging to the component.

### strongly_connected_components
```
strongly_connected_components(g::LightGraphs.DiGraph)
```
Computes the (strongly) connected components of a directed graph.

### weakly_connected_components
```
weakly_connected_components(g::LightGraphs.DiGraph)
```
Returns connected components of the undirected graph of `g`.

### has_self_loop
```
has_self_loop(g::Union{LightGraphs.DiGraph,LightGraphs.Graph})
```
Returns true if `g` is has any self loops.

### attracting_components
```
attracting_components(g::LightGraphs.DiGraph)
```
Returns a vector of vectors of integers representing lists of attracting components in `g`. The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.

### is_bipartite
```
is_bipartite(g::Union{LightGraphs.DiGraph,LightGraphs.Graph})
is_bipartite(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64)
```
Will return `true` if graph `g` is [bipartite](https://en.wikipedia.org/wiki/Bipartite_graph).

### condensation
```
condensation(g::LightGraphs.DiGraph)
condensation(g::LightGraphs.DiGraph, scc::Array{Array{Int64,1},1})
```
Computes the condensation graph of the strongly connected components.

Returns the condensation graph associated with `g`. The condensation `h` of a graph `g` is the directed graph where every node in `h` represents a strongly connected component in `g`, and the presence of an edge between between nodes in `h` indicates that there is at least one edge between the associated strongly connected components in `g`. The node numbering in `h` corresponds to the ordering of the components output from `strongly_connected_components`.

### period
```
period(g::LightGraphs.DiGraph)
```
Computes the (common) period for all nodes in a strongly connected graph.

## Cycle Detection
In graph theory, a cycle is defined to be a path that starts from some vertex
`v` and ends up at `v`.
### is_cyclic
```
is_cyclic(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph})
```
Tests whether a graph contains a cycle through depth-first search. It returns `true` when it finds a cycle, otherwise `false`.

##Simple Minimum Cut
Stoer's simple minimum cut gets the minimum cut of an undirected graph.
### mincut
```
mincut(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph})
mincut{T}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, distmx::AbstractArray{T,2})
```
Returns a tuple `(parity, bestcut)`, where `parity` is a vector of boolean values that determines the partition in `g` and `bestcut` is the weight of the cut that makes this partition. An optional `distmx` matrix may be specified; if omitted, edge distances are assumed to be 1.

### maximum_adjacency_visit
```
maximum_adjacency_visit(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph})
maximum_adjacency_visit{T}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, distmx::AbstractArray{T,2}, log::Bool, io::IO)
```
Returns the vertices in `g` traversed by maximum adjacency search. An optional `distmx` matrix may be specified; if omitted, edge distances are assumed to be 1. If `log` (default `false`) is `true`, visitor events will be printed to `io`, which defaults to `STDOUT`; otherwise, no event information will be displayed.

## Shortest-Path Algorithms
### General properties of shortest path algorithms
*  The distance from a vertex to itself is always `0`.
* The distance between two vertices with no connecting edge is always `Inf`.
### a_star
```
a_star(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64, t::Int64)
a_star{T<:Number}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64, t::Int64, distmx::AbstractArray{T<:Number,2})
a_star{T<:Number}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64, t::Int64, distmx::AbstractArray{T<:Number,2}, heuristic::Function)
```
Computes the shortest path between vertices `s` and `t` using the [A* search algorithm](http://en.wikipedia.org/wiki/A%2A_search_algorithm). An optional heuristic function and edge distance matrix may be supplied.

### dijkstra_shortest_paths
```
dijkstra_shortest_paths(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, srcs::Array{Int64,1})
dijkstra_shortest_paths{T}(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, srcs::Array{Int64,1}, distmx::AbstractArray{T,2})
dijkstra_shortest_paths(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, src::Int64)
dijkstra_shortest_paths{T}(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, src::Int64, distmx::AbstractArray{T,2})
```
Performs [Dijkstra's algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) on a graph, computing shortest distances between a source vertex `s` and all other nodes. Returns a `DijkstraState` that contains various traversal information (see below).

With `allpaths=true`, returns a `DijkstraState` that keeps track of all predecessors of a given vertex (see below).

### bellman_ford_shortest_paths
```
bellman_ford_shortest_paths(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, sources::AbstractArray{Int64,1})
bellman_ford_shortest_paths{T}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, sources::AbstractArray{Int64,1}, distmx::AbstractArray{T,2})
bellman_ford_shortest_paths(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, v::Int64)
bellman_ford_shortest_paths{T}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, v::Int64, distmx::AbstractArray{T,2})
```
Uses the [Bellman-Ford algorithm](http://en.wikipedia.org/wiki/Bellman–Ford_algorithm) to compute shortest paths between a source vertex `s` or a set of source vertices `ss`. Returns a `BellmanFordState` with relevant traversal information (see below).

### floyd_warshall_shortest_paths
```
floyd_warshall_shortest_paths(g::Union{LightGraphs.DiGraph,LightGraphs.Graph})
floyd_warshall_shortest_paths{T}(g::Union{LightGraphs.DiGraph,LightGraphs.Graph}, distmx::AbstractArray{T,2})
```
Uses the [Floyd-Warshall algorithm](http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm) to compute shortest paths between all pairs of vertices in graph `g`. Returns a `FloydWarshallState` with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.

Note that this algorithm may return a large amount of data (it will allocate on the order of $\mathcal{O}(nv^2)$).

## Path discovery / enumeration
### gdistances
```
gdistances(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, sources)
```
Returns the geodesic distances of graph `g` from source vertex `s` or a set of source vertices `ss`.

### gdistances!
```
gdistances!{DMap}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, s::Int64, dists::DMap)
gdistances!{DMap}(graph::Union{LightGraphs.DiGraph,LightGraphs.Graph}, sources::AbstractArray{Int64,1}, dists::DMap)
```
Returns the geodesic distances of graph `g` from source vertex `s` or a set of source vertices `ss`.

### enumerate_paths
```
enumerate_paths(s::LightGraphs.FloydWarshallState{T})
enumerate_paths(s::LightGraphs.FloydWarshallState{T}, v::Integer)
enumerate_paths(st::LightGraphs.FloydWarshallState{T}, s::Integer, d::Integer)
enumerate_paths(state::LightGraphs.AbstractPathState)
enumerate_paths(state::LightGraphs.AbstractPathState, dest::Array{Int64,1})
enumerate_paths(state::LightGraphs.AbstractPathState, dest)
```
Given a path state `state` of type `AbstractPathState` (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex `v`, a set of destination vertices `vs`, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.

For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: `enumerate_paths(state)` will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. `enumerate_paths(state, v)` will return a vector (indexed by destination vertex) of paths from source `v` to all other vertices. In addition, `enumerate_paths(state, v, d)` will return a vector representing the path from vertex `v` to vertex `d`.


### Path States
The `floyd_warshall_shortest_paths`, `bellman_ford_shortest_paths`,
`dijkstra_shortest_paths`, and `dijkstra_predecessor_and_distance` functions
return a state that contains various information about the graph learned during
traversal. The three state types have the following common information,
accessible via the type:

`.dists`
Holds a vector of distances computed, indexed by source vertex.

`.parents`
Holds a vector of parents of each source vertex. The parent of a source vertex
is always `0`.

In addition, the `dijkstra_predecessor_and_distance` function stores the
following information:

`.predecessors`
Holds a vector, indexed by vertex, of all the predecessors discovered during
shortest-path calculations. This keeps track of all parents when there are
multiple shortest paths available from the source.

`.pathcounts`
Holds a vector, indexed by vertex, of the path counts discovered during
traversal. This equals the length of each subvector in the `.predecessors`
output above.
