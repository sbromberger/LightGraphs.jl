var documenterSearchIndex = {"docs":
[{"location":"persistence/#Reading-and-writing-Graphs-1","page":"Reading / Writing Graphs","title":"Reading and writing Graphs","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Pages   = [\"persistence.md\"]","category":"page"},{"location":"persistence/#Saving-using-*LightGraphs.jl*-lg-format.-1","page":"Reading / Writing Graphs","title":"Saving using LightGraphs.jl lg format.","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Graphs may be written to I/O streams and files using the savegraph function and read with the loadgraph function. The default graph format is a bespoke compressed LightGraphs.jl format LG.","category":"page"},{"location":"persistence/#Example-1","page":"Reading / Writing Graphs","title":"Example","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"\ng = erdos_renyi(5, 0.2)\n\nsavegraph(\"mygraph.lgz\", g)\nreloaded_g = loadgraph(\"mygraph.lgz\")","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"In addition, graphs can also be saved in an uncompressed format using the compress=false option.","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"\nsavegraph(\"mygraph.lg\", g, compress=false)\n\nreloaded_g = loadgraph(\"mygraph.lg\")","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Finally, dictionaries of graphs can also be saved and subsequently re-loaded one by one.","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"graph_dict = {\"g1\" => erdos_renyi(5, 0.1),\n              \"g2\" => erdos_renyi(10, 0.2),\n              \"g3\" => erdos_renyi(2, 0.9)}\n\nsavegraph(\"mygraph_dict.lg\", graph_dict)\n\n# Re-load only graph g1\nreloaded_g1 = loadgraph(\"mygraph_dict.lg\", \"g1\")","category":"page"},{"location":"persistence/#Full-docs-1","page":"Reading / Writing Graphs","title":"Full docs","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Modules = [LightGraphs]\nPages   = [\"persistence/common.jl\"]\nPrivate = false","category":"page"},{"location":"persistence/#Reading-and-Writing-using-other-formats-using-GraphIO-1","page":"Reading / Writing Graphs","title":"Reading and Writing using other formats using GraphIO","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"The GraphIO.jl library provides tools for importing and exporting graph objects using common file types like edgelists, GraphML, Pajek NET, and more.","category":"page"},{"location":"linalg/#Linear-Algebra-1","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"LightGraphs.jl provides the following matrix operations on both directed and undirected graphs in the LinAlg submodule:","category":"page"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Order = [:type, :function]\nPages   = [\"linalg.md\"]","category":"page"},{"location":"linalg/#Full-Docs-1","page":"Linear Algebra","title":"Full Docs","text":"","category":"section"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Modules = [LightGraphs.LinAlg]\nPages   = [\n    \"graphmatrices.jl\",\n    \"Nonbacktracking.jl\",\n    \"spectral.jl\"\n]\nPrivate = false","category":"page"},{"location":"linalg/#LightGraphs.LinAlg","page":"Linear Algebra","title":"LightGraphs.LinAlg","text":"LinAlg\n\nA package for using the type system to check types of graph matrices.\n\n\n\n\n\n","category":"module"},{"location":"linalg/#LightGraphs.LinAlg.Adjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.Adjacency","text":"Adjacency{T}\n\nThe core Adjacency matrix structure. Keeps the vertex degrees around. Subtypes are used to represent the different normalizations of the adjacency matrix. Laplacian and its subtypes are used for the different Laplacian matrices.\n\nAdjacency(lapl::Laplacian) provides a generic function for getting the adjacency matrix of a Laplacian matrix. If your subtype of Laplacian does not provide a field A for the Adjacency instance, then attach another method to this function to provide an Adjacency{T} representation of the Laplacian. The Adjacency matrix here is the final subtype that corresponds to this type of Laplacian.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.AveragingAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.AveragingAdjacency","text":"AveragingAdjacency{T}\n\nThe matrix whose action is to average over each neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.AveragingLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.AveragingLaplacian","text":"AveragingLaplacian{T}\n\nLaplacian version of the AveragingAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.CombinatorialAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.CombinatorialAdjacency","text":"CombinatorialAdjacency{T,S,V}\n\nThe standard adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.GraphMatrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.GraphMatrix","text":"GraphMatrix{T}\n\nAn abstract type to allow opertions on any type of graph matrix\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.Noop","page":"Linear Algebra","title":"LightGraphs.LinAlg.Noop","text":"Noop\n\nA type that represents no action.\n\nImplementation Notes\n\nThe purpose of Noop is to help write more general code for the\n\ndifferent scaled GraphMatrix types.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.NormalizedAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.NormalizedAdjacency","text":"NormalizedAdjacency{T}\n\nThe normalized adjacency matrix is hatA = D^-12 A D^-12. If A is symmetric, then the normalized adjacency is also symmetric with real eigenvalues bounded by [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.NormalizedLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.NormalizedLaplacian","text":"NormalizedLaplacian{T}\n\nThe normalized Laplacian is hatL = I - D^-12 A D^-12. If A is symmetric, then the normalized Laplacian is also symmetric with positive eigenvalues bounded by 2.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.StochasticAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.StochasticAdjacency","text":"StochasticAdjacency{T}\n\nA transition matrix for the random walk.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.StochasticLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.StochasticLaplacian","text":"StochasticLaplacian{T}\n\nLaplacian version of the StochasticAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.degrees-Tuple{LightGraphs.LinAlg.CombinatorialAdjacency}","page":"Linear Algebra","title":"LightGraphs.LinAlg.degrees","text":"degrees(adjmat)\n\nReturn the degrees of a graph represented by the CombinatorialAdjacency adjmat.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.degrees-Tuple{LightGraphs.LinAlg.GraphMatrix}","page":"Linear Algebra","title":"LightGraphs.LinAlg.degrees","text":"degrees(graphmx)\n\nReturn the degrees of a graph represented by the graph matrix graphmx.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.symmetrize","page":"Linear Algebra","title":"LightGraphs.LinAlg.symmetrize","text":"symmetrize(A::SparseMatrix, which=:or)\n\nReturn a symmetric version of graph (represented by sparse matrix A) as a sparse matrix. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.symmetrize","page":"Linear Algebra","title":"LightGraphs.LinAlg.symmetrize","text":"symmetrize(adjmat, which=:or)\n\nReturn a symmetric version of graph (represented by CombinatorialAdjacency adjmat) as a CombinatorialAdjacency. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\nImplementation Notes\n\nOnly works on Adjacency because the normalizations don't commute with symmetrization.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.adjacency_matrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(g[, T=Int; dir=:out])\n\nReturn a sparse adjacency matrix for a graph, indexed by [u, v] vertices. Non-zero values indicate an edge from u to v. Users may override the default data type (Int) and specify an optional direction.\n\nOptional Arguments\n\ndir=:out: :in, :out, or :both are currently supported.\n\nImplementation Notes\n\nThis function is optimized for speed and directly manipulates CSC sparse matrix fields.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.adjacency_spectrum","page":"Linear Algebra","title":"LightGraphs.LinAlg.adjacency_spectrum","text":"adjacency_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the adjacency matrix for a graph g, indexed by vertex. Default values for T are the same as those in adjacency_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigs(adjacency_matrix(g);  kwargs...) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.incidence_matrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.incidence_matrix","text":"incidence_matrix(g[, T=Int; oriented=false])\n\nReturn a sparse node-arc incidence matrix for a graph, indexed by [v, i], where i is in 1:ne(g), indexing an edge e. For directed graphs, a value of -1 indicates that src(e) == v, while a value of 1 indicates that dst(e) == v. Otherwise, the value is 0. For undirected graphs, both entries are 1 by default (this behavior can be overridden by the oriented optional argument).\n\nIf oriented (default false) is true, for an undirected graph g, the matrix will contain arbitrary non-zero values representing connectivity between v and i.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.laplacian_matrix-Union{Tuple{AbstractGraph{U}}, Tuple{U}, Tuple{AbstractGraph{U},DataType}} where U","page":"Linear Algebra","title":"LightGraphs.LinAlg.laplacian_matrix","text":"laplacian_matrix(g[, T=Int; dir=:unspec])\n\nReturn a sparse Laplacian matrix for a graph g, indexed by [u, v] vertices. T defaults to Int for both graph types.\n\nOptional Arguments\n\ndir=:unspec: :unspec, :both, :in, and:outare currently supported. For undirected graphs,dirdefaults to:out; for directed graphs,dirdefaults to:both`.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.laplacian_spectrum","page":"Linear Algebra","title":"LightGraphs.LinAlg.laplacian_spectrum","text":"laplacian_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the Laplacian matrix for a graph g, indexed by vertex. Default values for T are the same as those in laplacian_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigs(laplacian_matrix(g);  kwargs...) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.spectral_distance","page":"Linear Algebra","title":"LightGraphs.LinAlg.spectral_distance","text":"spectral_distance(G₁, G₂ [, k])\n\nCompute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k greatest eigenvalues. If k is ommitted, uses full spectrum.\n\nReferences\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\n\n","category":"function"},{"location":"distance/#Distance-1","page":"Distance","title":"Distance","text":"","category":"section"},{"location":"distance/#","page":"Distance","title":"Distance","text":"LightGraphs.jl includes the following distance measurements:","category":"page"},{"location":"distance/#","page":"Distance","title":"Distance","text":"Order = [:type, :function]\nPages   = [\"distance.md\"]","category":"page"},{"location":"distance/#Full-Docs-1","page":"Distance","title":"Full Docs","text":"","category":"section"},{"location":"distance/#","page":"Distance","title":"Distance","text":"Modules = [LightGraphs]\nPages   = [\n    \"distance.jl\",\n    \"transitivity.jl\"\n]\nPrivate = false","category":"page"},{"location":"distance/#LightGraphs.BoundedMinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Distance","title":"LightGraphs.BoundedMinkowskiCost","text":"BoundedMinkowskiCost(μ₁, μ₂)\n\nReturn value similar to MinkowskiCost, but ensure costs smaller than 2τ.\n\nOptional Arguments\n\np=1: the p value for p-norm calculation. τ=1: value specifying half of the upper limit of the Minkowski cost.\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.MinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Distance","title":"LightGraphs.MinkowskiCost","text":"MinkowskiCost(μ₁, μ₂; p::Real=1)\n\nFor labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.\n\nOptional Arguments\n\np=1: the p value for p-norm calculation.\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.center-Tuple{Array{T,1} where T}","page":"Distance","title":"LightGraphs.center","text":"center(eccentricities)\ncenter(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\nExamples\n\njulia> using LightGraphs\n\njulia> center(star_graph(5))\n1-element Array{Int64,1}:\n 1\n\njulia> center(path_graph(5))\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.diameter-Tuple{Array{T,1} where T}","page":"Distance","title":"LightGraphs.diameter","text":"diameter(eccentricities)\ndiameter(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.\n\nExamples\n\njulia> using LightGraphs\n\njulia> diameter(star_graph(5))\n2\n\njulia> diameter(path_graph(5))\n4\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.eccentricity-Union{Tuple{T}, Tuple{AbstractGraph,Integer}, Tuple{AbstractGraph,Integer,AbstractArray{T,2}}} where T<:Real","page":"Distance","title":"LightGraphs.eccentricity","text":"eccentricity(g[, v][, distmx])\neccentricity(g[, vs][, distmx])\n\nReturn the eccentricity[ies] of a vertex / vertex list v or a set of vertices vs defaulting to the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to 1.\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\nPerformance\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\nImplementation Notes\n\nThe eccentricity vector returned by eccentricity() may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\nAn infinite path length is represented by the typemax of the distance matrix.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> eccentricity(g, 1)\n2\n\njulia> eccentricity(g, [1; 2])\n2-element Array{Int64,1}:\n 2\n 1\n\njulia> eccentricity(g, [1; 2], [0 2 0; 0.5 0 0.5; 0 2 0])\n2-element Array{Float64,1}:\n 2.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.edit_distance-Tuple{AbstractGraph,AbstractGraph}","page":"Distance","title":"LightGraphs.edit_distance","text":"edit_distance(G₁::AbstractGraph, G₂::AbstractGraph)\n\nCompute the edit distance between graphs G₁ and G₂. Return the minimum edit cost and edit path to transform graph G₁ into graph G₂. An edit path consists of a sequence of pairs of vertices(u,v) ∈ [0,|G₁|] × [0,|G₂|]` representing vertex operations:\n\n(0v): insertion of vertex v  G₂\n(u0): deletion of vertex u  G₁\n(u0v0): substitution of vertex u  G₁ by vertex v  G₂\n\nOptional Arguments\n\ninsert_cost::Function=v->1.0\ndelete_cost::Function=u->1.0\nsubst_cost::Function=(u,v)->0.5\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:\n\nedit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))\n\nheuristic::Function=DefaultEditHeuristic: a custom heuristic provided to the A*\n\nsearch in case the default heuristic is not satisfactory.\n\nPerformance\n\nGiven two graphs G₁  G₂, edit_distance(G₁, G₂) is faster to\n\ncompute than edit_distance(G₂, G₁). Consider swapping the arguments if involved costs are equivalent.\n\nThe use of simple Minkowski costs can improve performance considerably.\nExploit vertex attributes when designing operation costs.\n\nReferences\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\nAuthor\n\nJúlio Hoffimann Mendes (juliohm@stanford.edu)\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> edit_distance(g1, g2)\n(3.5, Tuple[(1, 2), (2, 1), (3, 0), (4, 3), (5, 0)])\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.periphery-Tuple{Array{T,1} where T}","page":"Distance","title":"LightGraphs.periphery","text":"periphery(eccentricities)\nperiphery(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\nExamples\n\njulia> using LightGraphs\n\njulia> periphery(star_graph(5))\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\njulia> periphery(path_graph(5))\n2-element Array{Int64,1}:\n 1\n 5\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.radius-Tuple{Array{T,1} where T}","page":"Distance","title":"LightGraphs.radius","text":"radius(eccentricities)\nradius(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.\n\nExamples\n\njulia> using LightGraphs\n\njulia> radius(star_graph(5))\n1\n\njulia> radius(path_graph(5))\n2\n\n\n\n\n\n","category":"method"},{"location":"distance/#LightGraphs.transitiveclosure","page":"Distance","title":"LightGraphs.transitiveclosure","text":"transitiveclosure(g, selflooped=false)\n\nCompute the transitive closure of a directed graph, using DFS. Return a graph representing the transitive closure. If selflooped is true, add self loops to the graph.\n\nPerformance\n\nTime complexity is mathcalO(EV).\n\nExamples\n\njulia> using LightGraphs\n\njulia> barbell = blockdiag(complete_digraph(3), complete_digraph(3));\n\njulia> add_edge!(barbell, 1, 4);\n\njulia> collect(edges(barbell))\n13-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 1\n Edge 2 => 3\n Edge 3 => 1\n Edge 3 => 2\n Edge 4 => 5\n Edge 4 => 6\n Edge 5 => 4\n Edge 5 => 6\n Edge 6 => 4\n Edge 6 => 5\n\njulia> collect(edges(transitiveclosure(barbell)))\n21-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n Edge 1 => 6\n Edge 2 => 1\n Edge 2 => 3\n Edge 2 => 4\n Edge 2 => 5\n Edge 2 => 6\n Edge 3 => 1\n Edge 3 => 2\n Edge 3 => 4\n Edge 3 => 5\n Edge 3 => 6\n Edge 4 => 5\n Edge 4 => 6\n Edge 5 => 4\n Edge 5 => 6\n Edge 6 => 4\n Edge 6 => 5\n\n\n\n\n\n","category":"function"},{"location":"distance/#LightGraphs.transitiveclosure!","page":"Distance","title":"LightGraphs.transitiveclosure!","text":"transitiveclosure!(g, selflooped=false)\n\nCompute the transitive closure of a directed graph, using DFS. If selflooped is true, add self loops to the graph.\n\nPerformance\n\nTime complexity is mathcalO(EV).\n\nImplementation Notes\n\nThis version of the function modifies the original graph.\n\n\n\n\n\n","category":"function"},{"location":"contributing/#Contributor-Guide-1","page":"Contributing","title":"Contributor Guide","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.","category":"page"},{"location":"contributing/#Bug-reports-1","page":"Contributing","title":"Bug reports","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"If you notice code that crashes, is incorrect, or is too slow, please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the condition. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Please include version numbers of all relevant libraries and Julia itself.","category":"page"},{"location":"contributing/#Development-guidelines-1","page":"Contributing","title":"Development guidelines","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\nPRs should contain one logical enhancement to the codebase.\nSquash commits in a PR.\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\nPRs introducing dependencies on Julia Base or the packages in the Julia Standard Library are ok.\nPRs introducing dependencies on third-party non-core \"leaf\" packages (no subdependencies except for Julia Base / Standard Library packages) are less ok.\nPRs introducing dependencies on third-party non-core non-leaf packages (that is, third-party packages that have dependencies on one or more other third-party packages) require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\nPut type assertions on all function arguments where conflict may arise (use abstract types, Union, or Any if necessary).\nIf the algorithm was presented in a paper, include a reference to the paper (e.g., a proper academic citation along with an eprint link).\nTake steps to ensure that code works correctly and efficiently on disconnected graphs.\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\nPrefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (e.g., condition && error(\"message\") is good; condition && i += 1 is not).\nWrite code to reuse memory wherever possible. For example:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"function f(g, v)\n    storage = Vector{Int}(undef, nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"should be rewritten as two functions","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(undef, nv(g))\n    return f!(g, v, storage)\nend\n\nfunction f!(g::AbstractGraph, v::Integer, storage::AbstractVector{Int})\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"This gives users the option of reusing memory and improving performance.","category":"page"},{"location":"contributing/#Minimizing-use-of-internal-struct-fields-1","page":"Contributing","title":"Minimizing use of internal struct fields","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Since LightGraphs supports multiple implementations of the graph datastructure using the AbstractGraph type, you should refrain from using the internal fields of structs such as fadjlist. Instead, you should use the functions provided in the api. Code that is instrumental to defining a concrete graph type can use the internal structure of that type for example graph generators in /src/StaticGraphs/generators/staticgraphs.jl use the fadjlist field in order to construct graphs efficiently.","category":"page"},{"location":"contributing/#Git-usage-1","page":"Contributing","title":"Git usage","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"In order to make it easier for you to review Pull Requests (PRs), you can add this to your git config file, which should be located at $HOME/.julia/dev/LightGraphs/.git/config. Follow the instructions here.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Locate the section for your github remote in the .git/config file. It looks like this:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/LightGraphs.jl.git","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now add the line fetch = +refs/pull/*/head:refs/remotes/origin/pr/* to this section. Obviously, change the github url to match your project's URL. It ends up looking like this:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/LightGraphs.jl.git\n    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now fetch all the pull requests:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"$ git fetch origin\nFrom github.com:JuliaGraphs/LightGraphs.jl\n * [new ref]         refs/pull/1000/head -> origin/pr/1000\n * [new ref]         refs/pull/1002/head -> origin/pr/1002\n * [new ref]         refs/pull/1004/head -> origin/pr/1004\n * [new ref]         refs/pull/1009/head -> origin/pr/1009\n...","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"To check out a particular pull request:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"$ git checkout pr/999\nBranch pr/999 set up to track remote branch pr/999 from origin.\nSwitched to a new branch 'pr/999'","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now you can test a PR by running git fetch && git checkout pr/PRNUMBER && julia -e 'Pkg.test(\"LightGraphs\")'","category":"page"},{"location":"parallel/#Parallel-Graph-Algorithms-1","page":"Parallel Algorithms","title":"Parallel Graph Algorithms","text":"","category":"section"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"LightGraphs.Parallel is a module for graph algorithms that are parallelized. Their names should be consistent with the serial versions in the main module. In order to use parallel versions of the algorithms you can write:","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"using LightGraphs\nimport LightGraphs.Parallel\n\ng = path_graph(10)\nbc = Parallel.betweenness_centrality(g)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"The arguments to parallel versions of functions match as closely as possible their serial versions  with potential addition default or keyword arguments to control parallel execution.  One exception is that for algorithms that cannot be meaningfully parallelized for  certain types of arguments a MethodError will be raised. For example, dijkstra_shortest_paths works for either a single or multiple source argument, but since the parallel version is slower when given only a single source, it will raise a MethodError.","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"g = Graph(10)\n# these work\nLightGraphs.dijkstra_shortest_paths(g,1)\nLightGraphs.dijkstra_shortest_paths(g, [1,2])\nParallel.dijkstra_shortest_paths(g, [1,2])\n# this doesn't\nParallel.dijkstra_shortest_paths(g,1)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Note that after importing or using LightGraphs.Parallel, you must fully qualify the version of the function you wish to use (using, e.g., LightGraphs.betweenness_centrality(g) for the sequential version and Parallel.betweenness_centrality(g) for the parallel version.)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"The following is a current list of parallel algorithms:","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Centrality measures:\nParallel.betweenness_centrality\nParallel.closeness_centrality\nParallel.pagerank\nParallel.radiality_centrality\nParallel.stress_centrality","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Distance measures:\nParallel.center\nParallel.diameter\nParallel.eccentricity\nParallel.radius\nShortest paths algorithms:\nParallel.bellman_ford_shortest_paths\nParallel.dijkstra_shortest_paths\nParallel.floyd_warshall_shortest_paths\nParalell.johnson_shortest_paths\nTraversal algorithms:\nParallel.bfs\nParallel.greedy_color","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Also note that in some cases, the arguments for the parallel versions may differ from the serial (standard) versions. As an example, parallel Dijkstra shortest paths takes advantage of multiple processors to execute centrality from multiple source vertices. It is an error to pass a single source vertex into the parallel version of dijkstrashortestpaths.","category":"page"},{"location":"pathing/#Path-and-Traversal-1","page":"Path and Traversal","title":"Path and Traversal","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.jl provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by [src,dst] vertices. That is, distmx[2,4] = 2.5 assigns the distance 2.5 to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs distmx[4,2] has to be set.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Default edge distances may be passed in via the","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.DefaultDistance","category":"page"},{"location":"pathing/#LightGraphs.DefaultDistance","page":"Path and Traversal","title":"LightGraphs.DefaultDistance","text":"DefaultDistance\n\nAn array-like structure that provides distance values of 1 for any src, dst combination.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"structure.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"distance values for undefined edges will be ignored, and\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.","category":"page"},{"location":"pathing/#Graph-Traversal-1","page":"Path and Traversal","title":"Graph Traversal","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Graph traversal refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"BreadthFirst,\nDepthFirst, and\nMaximumAdjacency.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"bfs_tree\ndfs_tree\nmaximum_adjacency_visit\nbfs_parents\nhas_path\ndiffusion\ndiffusion_rate\nmincut","category":"page"},{"location":"pathing/#Random-walks-1","page":"Path and Traversal","title":"Random walks","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs includes uniform random walks and self avoiding walks:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"randomwalk\nnon_backtracking_randomwalk\nself_avoiding_walk","category":"page"},{"location":"pathing/#Connectivity-/-Bipartiteness-1","page":"Path and Traversal","title":"Connectivity / Bipartiteness","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Graph connectivity functions are defined on both undirected and directed graphs:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nstrongly_connected_components_kosaraju\nweakly_connected_components\nhas_self_loops\nattracting_components\nis_bipartite\nbipartite_map\nbiconnected_components\ncondensation\nneighborhood\nneighborhood_dists\narticulation\nbridges\nperiod\nisgraphical","category":"page"},{"location":"pathing/#LightGraphs.is_connected","page":"Path and Traversal","title":"LightGraphs.is_connected","text":"is_connected(g)\n\nReturn true if graph g is connected. For directed graphs, return true if graph g is weakly connected.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> is_connected(g)\nfalse\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_connected(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.is_strongly_connected","page":"Path and Traversal","title":"LightGraphs.is_strongly_connected","text":"is_strongly_connected(g)\n\nReturn true if directed graph g is strongly connected.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_strongly_connected(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.is_weakly_connected","page":"Path and Traversal","title":"LightGraphs.is_weakly_connected","text":"is_weakly_connected(g)\n\nReturn true if the graph g is weakly connected. If g is undirected, this function is equivalent to is_connected(g).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_weakly_connected(g)\ntrue\n\njulia> g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> is_strongly_connected(g)\nfalse\n\njulia> is_weakly_connected(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.connected_components","page":"Path and Traversal","title":"LightGraphs.connected_components","text":"connected_components(g)\n\nReturn the connected components of an undirected graph g as a vector of components, with each element a vector of vertices belonging to the component.\n\nFor directed graphs, see strongly_connected_components and weakly_connected_components.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\njulia> g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.weakly_connected_components","page":"Path and Traversal","title":"LightGraphs.weakly_connected_components","text":"weakly_connected_components(g)\n\nReturn the weakly connected components of the graph g. This is equivalent to the connected components of the undirected equivalent of g. For undirected graphs this is equivalent to the connected_components of g.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> weakly_connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.has_self_loops","page":"Path and Traversal","title":"LightGraphs.has_self_loops","text":"has_self_loops(g)\n\nReturn true if g has any self loops.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_self_loops(g)\nfalse\n\njulia> add_edge!(g, 1, 1);\n\njulia> has_self_loops(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.attracting_components","page":"Path and Traversal","title":"LightGraphs.attracting_components","text":"attracting_components(g)\n\nReturn a vector of vectors of integers representing lists of attracting components in the directed graph g.\n\nThe attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> attracting_components(g)\n1-element Array{Array{Int64,1},1}:\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.biconnected_components","page":"Path and Traversal","title":"LightGraphs.biconnected_components","text":"biconnected_components(g) -> Vector{Vector{Edge{eltype(g)}}}\n\nCompute the biconnected components of an undirected graph gand return a vector of vectors containing each biconnected component.\n\nPerformance: Time complexity is mathcalO(V).\n\nExamples\n\njulia> using LightGraphs\n\njulia> biconnected_components(star_graph(5))\n4-element Array{Array{LightGraphs.SimpleGraphs.SimpleEdge,1},1}:\n [Edge 1 => 3]\n [Edge 1 => 4]\n [Edge 1 => 5]\n [Edge 1 => 2]\n\njulia> biconnected_components(cycle_graph(5))\n1-element Array{Array{LightGraphs.SimpleGraphs.SimpleEdge,1},1}:\n [Edge 1 => 5, Edge 4 => 5, Edge 3 => 4, Edge 2 => 3, Edge 1 => 2]\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.condensation","page":"Path and Traversal","title":"LightGraphs.condensation","text":"condensation(g[, scc])\n\nReturn the condensation graph of the strongly connected components scc in the directed graph g. If scc is missing, generate the strongly connected components first.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> foreach(println, edges(condensation(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.neighborhood","page":"Path and Traversal","title":"LightGraphs.neighborhood","text":"neighborhood(g, v, d, distmx=weights(g))\n\nReturn a vector of each vertex in g at a geodesic distance less than or equal to d, where distances may be specified by distmx.\n\nOptional Arguments\n\ndir=:out: If g is directed, this argument specifies the edge direction\n\nwith respect to v of the edges to be considered. Possible values: :in or :out.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> neighborhood(g, 1, 2)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> neighborhood(g, 1, 3)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.neighborhood_dists","page":"Path and Traversal","title":"LightGraphs.neighborhood_dists","text":"neighborhood_dists(g, v, d, distmx=weights(g))\n\nReturn a a vector of tuples representing each vertex which is at a geodesic distance less than or equal to d, along with its distance from v. Non-negative distances may be specified by distmx.\n\nOptional Arguments\n\ndir=:out: If g is directed, this argument specifies the edge direction\n\nwith respect to v of the edges to be considered. Possible values: :in or :out.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> neighborhood_dists(g, 1, 3)\n4-element Array{Tuple{Int64,Int64},1}:\n (1, 0)\n (2, 1)\n (3, 2)\n (4, 3)\n\njulia> neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])\n5-element Array{Tuple{Int64,Float64},1}:\n (1, 0.0)\n (2, 1.0)\n (3, 2.0)\n (4, 2.25)\n (5, 2.5)\n\njulia> neighborhood_dists(g, 4, 3)\n2-element Array{Tuple{Int64,Int64},1}:\n (4, 0)\n (5, 1)\n\njulia> neighborhood_dists(g, 4, 3, dir=:in)\n5-element Array{Tuple{Int64,Int64},1}:\n (4, 0)\n (3, 1)\n (5, 1)\n (2, 2)\n (1, 3)\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.articulation","page":"Path and Traversal","title":"LightGraphs.articulation","text":"articulation(g)\n\nCompute the articulation points of a connected graph g and return an array containing all cut vertices.\n\nExamples\n\njulia> using LightGraphs\n\njulia> articulation(star_graph(5))\n1-element Array{Int64,1}:\n 1\n\njulia> articulation(path_graph(5))\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.bridges","page":"Path and Traversal","title":"LightGraphs.bridges","text":"bridges(g)\n\nCompute the bridges of a connected graph g and return an array containing all bridges, i.e edges whose deletion increases the number of connected components of the graph.\n\nExamples\n\njulia> using LightGraphs\n\njulia> bridges(star_graph(5))\n8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n\njulia> bridges(path_graph(5))\n8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 4 => 5\n Edge 3 => 4\n Edge 2 => 3\n Edge 1 => 2\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.period","page":"Path and Traversal","title":"LightGraphs.period","text":"period(g)\n\nReturn the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> period(g)\n3\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.isgraphical","page":"Path and Traversal","title":"LightGraphs.isgraphical","text":"isgraphical(degs)\n\nReturn true if the degree sequence degs is graphical. A sequence of integers is called graphical, if there exists a graph where the degrees of its vertices form that same sequence.\n\nPerformance\n\nTime complexity: mathcalO(degs*log(degs)).\n\nImplementation Notes\n\nAccording to Erdös-Gallai theorem, a degree sequence d_1 d_n (sorted in descending order) is graphic iff the sum of vertex degrees is even and the sequence obeys the property -\n\nsum_i=1^r d_i leq r(r-1) + sum_i=r+1^n min(rd_i)\n\nfor each integer r <= n-1\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Cycle-Detection-1","page":"Path and Traversal","title":"Cycle Detection","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"In graph theory, a cycle is defined to be a path that starts from some vertex v and ends up at v.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"is_cyclic\nmaxsimplecycles\nsimplecycles\nsimplecycles_iter\nsimplecycles_hawick_james\nsimplecyclescount\nsimplecycleslength\nsimplecycles_limited_length\nkarp_minimum_cycle_mean","category":"page"},{"location":"pathing/#LightGraphs.maxsimplecycles","page":"Path and Traversal","title":"LightGraphs.maxsimplecycles","text":"maxsimplecycles(dg::::IsDirected, byscc::Bool = true)\n\nCompute the theoretical maximum number of cycles in the directed graph dg.\n\nThe computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (byscc parameter).\n\nPerformance\n\nA more efficient version is possible.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecycles","page":"Path and Traversal","title":"LightGraphs.simplecycles","text":"simplecycles(dg::::IsDirected)\n\nCompute and return all cycles of the given directed graph using Johnson's algorithm.\n\nPerformance\n\nThe number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – simplecycles_iter – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function maxsimplecycles(dg::DiGraph, byscc::Bool = true). If you only need short cycles of a limited length, simplecycles_limited_length can be more efficient.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecycles(complete_digraph(3))\n5-element Array{Array{Int64,1},1}:\n [1, 2]\n [1, 2, 3]\n [1, 3]\n [1, 3, 2]\n [2, 3]\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecycles_iter","page":"Path and Traversal","title":"LightGraphs.simplecycles_iter","text":"simplecycles_iter(dg::DiGraph, ceiling = 10^6)\n\nSearch all cycles of the given directed graph, using Johnson's algorithm, up to the ceiling (to avoid memory overload).\n\nImplementation Notes\n\nIf the graph is small, the ceiling will not be reached and simplecycles(dg::DiGraph) is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the ceiling is not reached, a subset of them otherwise.\n\nTo get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecycles_hawick_james","page":"Path and Traversal","title":"LightGraphs.simplecycles_hawick_james","text":"simplecycles_hawick_james(g)\n\nFind circuits (including self-loops) in g using the algorithm of Hawick & James.\n\nReferences\n\nHawick & James, \"Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs\", 2008\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecyclescount","page":"Path and Traversal","title":"LightGraphs.simplecyclescount","text":"simplecyclescount(dg::DiGraph, ceiling = 10^6)\n\nCount the number of cycles in a directed graph, using Johnson's algorithm. Return the minimum of the ceiling and the number of cycles.\n\nImplementation Notes\n\nThe ceiling is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function maxsimplecycles(dg::DiGraph, byscc::Bool = true) to get an idea of the theoretical maximum number or cycles.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecyclescount(complete_digraph(6))\n409\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecycleslength","page":"Path and Traversal","title":"LightGraphs.simplecycleslength","text":"simplecycleslength(dg::DiGraph, ceiling = 10^6)\n\nSearch all cycles of the given directed graph, using Johnson's algorithm, and return a tuple representing the cycle length and the number of cycles.\n\nImplementation Notes\n\nTo get an idea of the possible number of cycles, using function maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.\n\nIf the ceiling is reached (ncycles = ceiling), the output is only a subset of the cycles lengths.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecycleslength(complete_digraph(16))\n([0, 1, 1, 1, 1, 1, 2, 10, 73, 511, 3066, 15329, 61313, 183939, 367876, 367876], 1000000)\n\njulia> simplecycleslength(wheel_digraph(16))\n([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], 1)\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.simplecycles_limited_length","page":"Path and Traversal","title":"LightGraphs.simplecycles_limited_length","text":"simplecycles_limited_length(g, n, ceiling=10^6)\n\nCompute and return at most ceiling cycles of length at most n of the given graph. Both directed and undirected graphs are supported.\n\nPerformance\n\nThe number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, simplecycles or simplecycles_iter may be more efficient.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.karp_minimum_cycle_mean","page":"Path and Traversal","title":"LightGraphs.karp_minimum_cycle_mean","text":"karp_minimum_cycle_mean(g[, distmx])\n\nReturn minimum cycle mean of the directed graph g with optional edge weights contained in distmx.\n\nReferences\n\nKarp.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Minimum-Spanning-Trees-(MST)-Algorithms-1","page":"Path and Traversal","title":"Minimum Spanning Trees (MST) Algorithms","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"kruskal_mst\nprim_mst","category":"page"},{"location":"pathing/#LightGraphs.kruskal_mst","page":"Path and Traversal","title":"LightGraphs.kruskal_mst","text":"kruskal_mst(g, distmx=weights(g); minimize=true)\n\nReturn a vector of edges representing the minimum (by default) spanning tree of a connected, undirected graph g with optional distance matrix distmx using Kruskal's algorithm.\n\nOptional Arguments\n\nminimize=true: if set to false, calculate the maximum spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.prim_mst","page":"Path and Traversal","title":"LightGraphs.prim_mst","text":"prim_mst(g, distmx=weights(g))\n\nReturn a vector of edges representing the minimum spanning tree of a connected, undirected graph g with optional distance matrix distmx using Prim's algorithm. Return a vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Shortest-Path-Algorithms-1","page":"Path and Traversal","title":"Shortest-Path Algorithms","text":"","category":"section"},{"location":"pathing/#General-properties-of-shortest-path-algorithms-1","page":"Path and Traversal","title":"General properties of shortest path algorithms","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The distance from a vertex to itself is always 0.\nThe distance between two vertices with no connecting edge is always Inf.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"a_star\ndijkstra_shortest_paths\ndesopo_pape_shortest_paths\nbellman_ford_shortest_paths\nfloyd_warshall_shortest_paths\nyen_k_shortest_paths\nspfa_shortest_paths","category":"page"},{"location":"pathing/#LightGraphs.a_star","page":"Path and Traversal","title":"LightGraphs.a_star","text":"a_star(g, s, t[, distmx][, heuristic])\n\nReturn a vector of edges comprising the shortest path between vertices s and t using the A* search algorithm. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to LightGraphs.DefaultDistance and the heuristic is set to n -> 0.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.dijkstra_shortest_paths","page":"Path and Traversal","title":"LightGraphs.dijkstra_shortest_paths","text":"dijkstra_shortest_paths(g, srcs, distmx=weights(g));\n\nPerform Dijkstra's algorithm on a graph, computing shortest distances between srcs and all other vertices. Return a LightGraphs.DijkstraState that contains various traversal information.\n\nOptional Arguments\n\nallpaths=false: If true, returns a LightGraphs.DijkstraState that keeps track of all\n\npredecessors of a given vertex.\n\nPerformance\n\nIf using a sparse matrix for distmx, you may achieve better performance by passing in a transpose of its sparse transpose. That is, assuming D is the sparse distance matrix:\n\nD = transpose(sparse(transpose(D)))\n\nBe aware that realizing the sparse transpose of D incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to dijkstra_shortest_paths with the distance matrix are planned.\n\nExamples\n\njulia> using LightGraphs\n\njulia> ds = dijkstra_shortest_paths(cycle_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 2\n\njulia> ds = dijkstra_shortest_paths(path_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.desopo_pape_shortest_paths","page":"Path and Traversal","title":"LightGraphs.desopo_pape_shortest_paths","text":"desopo_pape_shortest_paths(g, src, distmx=weights(g))\n\nCompute shortest paths between a source src and all other nodes in graph g using the D'Esopo-Pape algorithm. Return a LightGraphs.DEsopoPapeState with relevant traversal information.\n\nExamples\n\njulia> using LightGraphs\n\njulia> ds = desopo_pape_shortest_paths(cycle_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 2\n\njulia> ds = desopo_pape_shortest_paths(path_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.bellman_ford_shortest_paths","page":"Path and Traversal","title":"LightGraphs.bellman_ford_shortest_paths","text":"bellman_ford_shortest_paths(g, s, distmx=weights(g))\nbellman_ford_shortest_paths(g, ss, distmx=weights(g))\n\nCompute shortest paths between a source s (or list of sources ss) and all other nodes in graph g using the Bellman-Ford algorithm. Return a LightGraphs.BellmanFordState with relevant traversal information.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.floyd_warshall_shortest_paths","page":"Path and Traversal","title":"LightGraphs.floyd_warshall_shortest_paths","text":"floyd_warshall_shortest_paths(g, distmx=weights(g))\n\nUse the Floyd-Warshall algorithm to compute the shortest paths between all pairs of vertices in graph g using an optional distance matrix distmx. Return a LightGraphs.FloydWarshallState with relevant traversal information.\n\nPerformance\n\nSpace complexity is on the order of mathcalO(V^2).\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.yen_k_shortest_paths","page":"Path and Traversal","title":"LightGraphs.yen_k_shortest_paths","text":"yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);\n\nPerform Yen's algorithm on a graph, computing k-shortest distances between source and target other vertices. Return a YenState that contains distances and paths.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Path-discovery-/-enumeration-1","page":"Path and Traversal","title":"Path discovery / enumeration","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"gdistances\ngdistances!\nenumerate_paths","category":"page"},{"location":"pathing/#LightGraphs.enumerate_paths","page":"Path and Traversal","title":"LightGraphs.enumerate_paths","text":"enumerate_paths(state[, vs])\n\nGiven a path state state of type AbstractPathState, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\nImplementation Notes\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: enumerate_paths(state) will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. enumerate_paths(state, v) will return a vector (indexed by destination vertex) of paths from source v to all other vertices. In addition, enumerate_paths(state, v, d) will return a vector representing the path from vertex v to vertex d.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Path-States-1","page":"Path and Traversal","title":"Path States","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"All path states derive from","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.AbstractPathState","category":"page"},{"location":"pathing/#LightGraphs.AbstractPathState","page":"Path and Traversal","title":"LightGraphs.AbstractPathState","text":"AbstractPathState\n\nAn abstract type that provides information from shortest paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The dijkstra_shortest_paths, floyd_warshall_shortest_paths, bellman_ford_shortest_paths, and yen_shortest_paths functions return states that contain various  information about the graph learned during traversal.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.DijkstraState\nLightGraphs.DEsopoPapeState\nLightGraphs.BellmanFordState\nLightGraphs.FloydWarshallState\nLightGraphs.YenState","category":"page"},{"location":"pathing/#LightGraphs.DijkstraState","page":"Path and Traversal","title":"LightGraphs.DijkstraState","text":"struct DijkstraState{T, U}\n\nAn AbstractPathState designed for Dijkstra shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#LightGraphs.DEsopoPapeState","page":"Path and Traversal","title":"LightGraphs.DEsopoPapeState","text":"struct DEposoPapeState{T, U}\n\nAn AbstractPathState designed for D`Esopo-Pape shortest-path calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#LightGraphs.BellmanFordState","page":"Path and Traversal","title":"LightGraphs.BellmanFordState","text":"BellmanFordState{T, U}\n\nAn AbstractPathState designed for Bellman-Ford shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#LightGraphs.FloydWarshallState","page":"Path and Traversal","title":"LightGraphs.FloydWarshallState","text":"struct FloydWarshallState{T, U}\n\nAn AbstractPathState designed for Floyd-Warshall shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#LightGraphs.YenState","page":"Path and Traversal","title":"LightGraphs.YenState","text":"struct YenState{T, U}\n\nDesigned for yen k-shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The above state types (with the exception of YenState) have the following common information, accessible via the type:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".dists Holds a vector of distances computed, indexed by source vertex.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".parents Holds a vector of parents of each vertex on the paths. The parent of a source vertex is always 0.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"(YenState substitutes .paths for .parents.)","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"In addition, the following information may be populated with the appropriate arguments to dijkstra_shortest_paths:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".predecessors Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".pathcounts Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the .predecessors output above.","category":"page"},{"location":"generators/#Making-and-Modifying-Graphs-1","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl provides a number of methods for creating a graph object, including tools for building and modifying graph objects, a wide array of graph generator functions, and the ability to read and write graphs from files (using GraphIO.jl).","category":"page"},{"location":"generators/#Modifying-graphs-1","page":"Making and Modifying Graphs","title":"Modifying graphs","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl offers a range of tools for modifying graphs, including:","category":"page"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"SimpleGraph\nSimpleGraphFromIterator\nSimpleDiGraph\nSimpleDiGraphFromIterator\nEdge\nadd_edge!\nrem_edge!\nadd_vertex!\nadd_vertices!\nrem_vertex!\nzero","category":"page"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleGraph","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}\n\nA type representing an undirected graph.\n\n\n\n\n\n","category":"type"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleGraphFromIterator","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleGraphFromIterator","text":"SimpleGraphFromIterator(iter)\n\nCreate a SimpleGraph from an iterator iter. The elements in iter must be of type <: SimpleEdge.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> h = SimpleGraphFromIterator(edges(g));\n\njulia> collect(edges(h))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleDiGraph","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}\n\nA type representing a directed graph.\n\n\n\n\n\n","category":"type"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleDiGraphFromIterator","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleDiGraphFromIterator","text":"SimpleDiGraphFromIterator(iter)\n\nCreate a SimpleDiGraph from an iterator iter. The elements in iter must be of type <: SimpleEdge.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 1);\n\njulia> h = SimpleDiGraphFromIterator(edges(g))\n{2, 2} directed simple Int64 graph\n\njulia> collect(edges(h))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 1\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.Edge","page":"Making and Modifying Graphs","title":"LightGraphs.Edge","text":"Edge\n\nA datastruture representing an edge between two vertices in a Graph or DiGraph.\n\n\n\n\n\n","category":"type"},{"location":"generators/#LightGraphs.SimpleGraphs.add_edge!","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.add_edge!","text":"add_edge!(g, e)\n\nAdd an edge e to graph g. Return true if edge was added successfully, otherwise return false.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2)\ntrue\n\njulia> add_edge!(g, 2, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.rem_edge!","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.rem_edge!","text":"rem_edge!(g, e)\n\nRemove an edge e from graph g. Return true if edge was removed successfully, otherwise return false.\n\nImplementation Notes\n\nIf rem_edge! returns false, the graph may be in an indeterminate state, as there are multiple points where the function can exit with false.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> rem_edge!(g, 1, 2)\ntrue\n\njulia> rem_edge!(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.add_vertex!","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.add_vertex!","text":"add_vertex!(g)\n\nAdd a new vertex to the graph g. Return true if addition was successful.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(Int8(typemax(Int8) - 1))\n{126, 0} undirected simple Int8 graph\n\njulia> add_vertex!(g)\ntrue\n\njulia> add_vertex!(g)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.add_vertices!","page":"Making and Modifying Graphs","title":"LightGraphs.add_vertices!","text":"add_vertices!(g, n)\n\nAdd n new vertices to the graph g. Return the number of vertices that were added successfully.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph()\n{0, 0} undirected simple Int64 graph\n\njulia> add_vertices!(g, 2)\n2\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.rem_vertex!","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(g, v)\n\nRemove the vertex v from graph g. Return false if removal fails (e.g., if vertex is not in the graph); true otherwise.\n\nPerformance\n\nTime complexity is mathcalO(k^2), where k is the max of the degrees of vertex v and vertex V.\n\nImplementation Notes\n\nThis operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices v  and V, and removing the last vertex V from the graph. After removal the vertices in g will be indexed by 1V-1.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> rem_vertex!(g, 2)\ntrue\n\njulia> rem_vertex!(g, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#Base.zero","page":"Making and Modifying Graphs","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"function"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"In addition to these core functions, more advanced operators can be found in Operators.","category":"page"},{"location":"generators/#Graph-Generators-1","page":"Making and Modifying Graphs","title":"Graph Generators","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl implements numerous graph generators, including random graph generators, constructors for classic graphs, numerous small graphs with familiar topologies, and random and static graphs embedded in Euclidean space.","category":"page"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Modules = [LightGraphs]\nPages   = [\"generators.md\"]","category":"page"},{"location":"generators/#Datasets-1","page":"Making and Modifying Graphs","title":"Datasets","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Other notorious graphs and integration with the MatrixDepot.jl package are available in the Datasets submodule of the companion package LightGraphsExtras.jl. Selected graphs from the Stanford Large Network Dataset Collection may be found in the SNAPDatasets.jl package.","category":"page"},{"location":"generators/#All-Generators-1","page":"Making and Modifying Graphs","title":"All Generators","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Modules = [LightGraphs.SimpleGraphs]\nPages   = [\n    \"generators/randgraphs.jl\",\n    \"generators/staticgraphs.jl\",\n    \"generators/smallgraphs.jl\",\n    \"generators/euclideangraphs.jl\"]\nPrivate = false","category":"page"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}(nv, ne; seed=-1)\n\nConstruct a random SimpleDiGraph{T} with nv vertices and ne edges. The graph is sampled uniformly from all such graphs. If seed >= 0, a random generator is seeded with this value. If not specified, the element type T is the type of nv.\n\nSee also\n\nerdos_renyi\n\nExamples\n\njulia> SimpleDiGraph(5, 7)\n{5, 7} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,Channel}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne, edgestream::Channel)\n\nConstruct a SimpleGraph{T} with nv vertices and ne edges from edgestream. Can result in less than ne edges if the channel edgestream is closed prematurely. Duplicate edges are only counted once. The element type is the type of nv.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,StochasticBlockModel}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne, smb::StochasticBlockModel)\n\nConstruct a random SimpleGraph{T} with nv vertices and ne edges. The graph is sampled according to the stochastic block model smb. The element type is the type of nv.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.SimpleGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne; seed=-1)\n\nConstruct a random SimpleGraph{T} with nv vertices and ne edges. The graph is sampled uniformly from all such graphs. If seed >= 0, a random generator is seeded with this value. If not specified, the element type T is the type of nv.\n\nSee also\n\nerdos_renyi\n\nExamples\n\njulia> SimpleGraph(5, 7)\n{5, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.StochasticBlockModel","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.StochasticBlockModel","text":"StochasticBlockModel{T,P}\n\nA type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge (i,j) depends only on the block labels of vertex i and vertex j.\n\nThe assignement is stored in nodemap and the block affinities a k by k matrix is stored in affinities.\n\naffinities[k,l] is the probability of an edge between any vertex in block k and any vertex in block l.\n\nImplementation Notes\n\nGraphs are generated by taking random ij  V and flipping a coin with probability affinities[nodemap[i],nodemap[j]].\n\n\n\n\n\n","category":"type"},{"location":"generators/#LightGraphs.SimpleGraphs.barabasi_albert!-Tuple{AbstractGraph,Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.barabasi_albert!","text":"barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph g. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> g = cycle_graph(4)\n{4, 4} undirected simple Int64 graph\n\njulia> barabasi_albert!(g, 16, 3);\n\njulia> g\n{16, 40} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.barabasi_albert","text":"barabasi_albert(n::Integer, n0::Integer, k::Integer)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph with n0 vertices. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\ncomplete=false: if true, use a complete graph for the initial graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> barabasi_albert(10, 3, 2)\n{10, 14} undirected simple Int64 graph\n\njulia> barabasi_albert(100, Int8(10), 3, is_directed=true, seed=123)\n{100, 270} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.barabasi_albert","text":"barabasi_albert(n, k)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph with k vertices. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\ncomplete=false: if true, use a complete graph for the initial graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> barabasi_albert(50, 3)\n{50, 141} undirected simple Int64 graph\n\njulia> barabasi_albert(100, Int8(10), is_directed=true, complete=true, seed=123)\n{100, 990} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.blockcounts-Tuple{StochasticBlockModel,AbstractArray{T,2} where T}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.blockcounts","text":"blockcounts(sbm, A)\n\nCount the number of edges that go between each block.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.dorogovtsev_mendes-Tuple{Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.dorogovtsev_mendes","text":"dorogovtsev_mendes(n)\n\nGenerate a random n vertex graph by the Dorogovtsev-Mendes method (with n \\ge 3).\n\nThe Dorogovtsev-Mendes process begins with a triangle graph and inserts n-3 additional vertices. Each time a vertex is added, a random edge is selected and the new vertex is connected to the two endpoints of the chosen edge. This creates graphs with a many triangles and a high local clustering coefficient.\n\nIt is often useful to track the evolution of the graph as vertices are added, you can access the graph from the tth stage of this algorithm by accessing the first t vertices with g[1:t].\n\nReferences\n\nhttp://graphstream-project.org/doc/Generators/Dorogovtsev-Mendes-generator/\nhttps://arxiv.org/pdf/cond-mat/0106144.pdf#page=24\n\nExamples\n\njulia> dorogovtsev_mendes(10)\n{10, 17} undirected simple Int64 graph\n\njulia> dorogovtsev_mendes(11, seed=123)\n{11, 19} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.erdos_renyi","text":"erdos_renyi(n, ne)\n\nCreate an Erdős–Rényi random graph with n vertices and ne edges.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> erdos_renyi(10, 30)\n{10, 30} undirected simple Int64 graph\n\njulia> erdos_renyi(10, 30, is_directed=true, seed=123)\n{10, 30} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Real}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.erdos_renyi","text":"erdos_renyi(n, p)\n\nCreate an Erdős–Rényi random graph with n vertices. Edges are added between pairs of vertices with probability p.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> erdos_renyi(10, 0.5)\n{10, 20} undirected simple Int64 graph\n\njulia> erdos_renyi(10, 0.5, is_directed=true, seed=123)\n{10, 49} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.expected_degree_graph-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Real","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.expected_degree_graph","text":"expected_degree_graph(ω)\n\nGiven a vector of expected degrees ω indexed by vertex, create a random undirected graph in which vertices i and j are connected with probability ω[i]*ω[j]/sum(ω).\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nImplementation Notes\n\nThe algorithm should work well for maximum(ω) << sum(ω). As maximum(ω) approaches sum(ω), some deviations from the expected values are likely.\n\nReferences\n\nConnected Components in Random Graphs with Given Expected Degree Sequences, Linyuan Lu and Fan Chung. https://link.springer.com/article/10.1007%2FPL00012580\nEfficient Generation of Networks with Given Expected Degrees, Joel C. Miller and Aric Hagberg. https://doi.org/10.1007/978-3-642-21286-4_10\n\nExamples\n\n# 1)\njulia> g = expected_degree_graph([3, 1//2, 1//2, 1//2, 1//2])\n{5, 3} undirected simple Int64 graph\n\njulia> print(degree(g))\n[3, 0, 1, 1, 1]\n\n# 2)\njulia> g = expected_degree_graph([0.5, 0.5, 0.5], seed=123)\n{3, 1} undirected simple Int64 graph\n\njulia> print(degree(g))\n[1, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.kronecker","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.kronecker","text":"kronecker(SCALE, edgefactor, A=0.57, B=0.19, C=0.19; seed=-1)\n\nGenerate a directed Kronecker graph with the default Graph500 parameters.\n\n\n\nReferences\n\nhttp://www.graph500.org/specifications#alg:generator\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.make_edgestream","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.make_edgestream","text":"make_edgestream(sbm)\n\nTake an infinite sample from the Stochastic Block Model sbm. Pass to Graph(nvg, neg, edgestream) to get a Graph object based on sbm.\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.SimpleGraphs.random_configuration_model-Union{Tuple{T}, Tuple{Integer,Array{T,N} where N}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.random_configuration_model","text":"random_configuration_model(n, ks)\n\nCreate a random undirected graph according to the configuration model containing n vertices, with each node i having degree k[i].\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\ncheck_graphical=false: if true, ensure that k is a graphical sequence\n\n(see isgraphical).\n\nPerformance\n\nTime complexity is approximately mathcalO(n bark^2).\n\nImplementation Notes\n\nAllocates an array of n bark Ints.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.random_orientation_dag-Union{Tuple{SimpleGraph{T}}, Tuple{T}, Tuple{SimpleGraph{T},Int64}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.random_orientation_dag","text":"random_orientation_dag(g)\n\nGenerate a random oriented acyclical digraph. The function takes in a simple graph and a random number generator as an argument. The probability of each directional acyclic graph randomly being generated depends on the architecture of the original directed graph.\n\nDAG's have a finite topological order; this order is randomly generated via \"order = randperm()\".\n\nExamples\n\njulia> random_orientation_dag(complete_graph(10))\n{10, 45} directed simple Int64 graph\n\njulia> random_orientation_dag(star_graph(Int8(10)), 123)\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.random_regular_digraph-Tuple{Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.random_regular_digraph","text":"random_regular_digraph(n, k)\n\nCreate a random directed regular graph with n vertices, each with degree k.\n\nOptional Arguments\n\ndir=:out: the direction of the edges for degree parameter.\nseed=-1: set the RNG seed.\n\nImplementation Notes\n\nAllocates an n  n sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.random_regular_graph-Tuple{Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.random_regular_graph","text":"random_regular_graph(n, k)\n\nCreate a random undirected regular graph with n vertices, each with degree k.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is approximately mathcalO(nk^2).\n\nImplementation Notes\n\nAllocates an array of nk Ints, and . For k  fracn2, generates a graph of degree n-k-1 and returns its complement.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.random_tournament_digraph-Tuple{Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.random_tournament_digraph","text":"random_tournament_digraph(n)\n\nCreate a random directed tournament graph with n vertices.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> random_tournament_digraph(5)\n{5, 10} directed simple Int64 graph\n\njulia> random_tournament_digraph(Int8(10), seed=123)\n{10, 45} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{Integer,Array{T,1}}} where T<:Real","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.static_fitness_model","text":"static_fitness_model(m, fitness)\n\nGenerate a random graph with fitness vertices and m edges, in which the probability of the existence of Edge_ij is proportional to fitness_i  fitness_j.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\nExamples\n\njulia> g = static_fitness_model(5, [1, 1, 0.5, 0.1])\n{4, 5} undirected simple Int64 graph\n\njulia> edges(g) |> collect\n5-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 4\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{S}, Tuple{Integer,Array{T,1},Array{S,1}}} where T<:Real where S<:Real","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.static_fitness_model","text":"static_fitness_model(m, fitness_out, fitness_in)\n\nGenerate a random directed graph with fitness_out + fitness_in vertices and m edges, in which the probability of the existence of Edge_ij is proportional with respect to i  fitness_out and j  fitness_in.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\nExamples\n\njulia> g = static_fitness_model(6, [1, 0.2, 0.2, 0.2], [0.1, 0.1, 0.1, 0.9]; seed=123)\n{4, 6} directed simple Int64 graph\n\njulia> edges(g) |> collect\n6-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 4\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real,Float64}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.static_scale_free","text":"static_scale_free(n, m, α_out, α_in)\n\nGenerate a random graph with n vertices, m edges and expected power-law degree distribution with exponent α_out for outbound edges and α_in for inbound edges.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\nfinite_size_correction=true: determines whether to use the finite size correction\n\nproposed by Cho et al.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.static_scale_free","text":"static_scale_free(n, m, α)\n\nGenerate a random graph with n vertices, m edges and expected power-law degree distribution with exponent α.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\nfinite_size_correction=true: determines whether to use the finite size correction\n\nproposed by Cho et al.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{Array{T,2},Array{U,1}}} where T<:Real where U<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.stochastic_block_model","text":"stochastic_block_model(c, n)\n\nReturn a Graph generated according to the Stochastic Block Model (SBM).\n\nc[a,b] : Mean number of neighbors of a vertex in block a belonging to block b.            Only the upper triangular part is considered, since the lower traingular is            determined by cba = cab * fracnanb. n[a] : Number of vertices in block a\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nFor a dynamic version of the SBM see the StochasticBlockModel type and related functions.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{T,T,Array{U,1}}} where T<:Real where U<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.stochastic_block_model","text":"stochastic_block_model(cint, cext, n)\n\nReturn a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with c_aa=cint, and c_ab=cext.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.watts_strogatz-Tuple{Integer,Integer,Real}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.watts_strogatz","text":"watts_strogatz(n, k, β)\n\nReturn a Watts-Strogatz small model random graph with n vertices, each with degree k. Edges are randomized per the model based on probability β.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> watts_strogatz(10, 4, 0.3)\n{10, 20} undirected simple Int64 graph\n\njulia> watts_strogatz(Int8(10), 4, 0.8, is_directed=true, seed=123)\n{10, 20} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.barbell_graph-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.barbell_graph","text":"barbell_graph(n1, n2)\n\nCreate a barbell graph consisting of a clique of size n1 connected by an edge to a clique of size n2.\n\nImplementation Notes\n\nPreserves the eltype of n1 and n2. Will error if the required number of vertices exceeds the eltype. n1 and n2 must be at least 1 so that both cliques are non-empty. The cliques are organized with nodes 1:n1 being the left clique and n1+1:n1+n2 being the right clique. The cliques are connected by and edge (n1, n1+1).\n\nExamples\n\njulia> barbell_graph(3, 4)\n{7, 10} undirected simple Int64 graph\n\njulia> barbell_graph(Int8(5), Int8(5))\n{10, 21} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.binary_tree-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.binary_tree","text":"binary_tree(k::Integer)\n\nCreate a binary tree of depth k.\n\nExamples\n\njulia> binary_tree(4)\n{15, 14} undirected simple Int64 graph\n\njulia> binary_tree(Int8(5))\n{31, 30} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.circular_ladder_graph-Tuple{Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.circular_ladder_graph","text":"circular_ladder_graph(n)\n\nCreate a circular ladder graph consisting of 2n nodes and 3n edges. This is also known as the prism graph.\n\nImplementation Notes\n\nPreserves the eltype of the partitions vector. Will error if the required number of vertices exceeds the eltype. n must be at least 3 to avoid self-loops and multi-edges.\n\nExamples\n\njulia> circular_ladder_graph(3)\n{6, 9} undirected simple Int64 graph\n\njulia> circular_ladder_graph(Int8(4))\n{8, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.clique_graph-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.clique_graph","text":"clique_graph(k, n)\n\nCreate a graph consisting of n connected k-cliques.\n\nExamples\n\njulia> clique_graph(4, 10)\n{40, 70} undirected simple Int64 graph\n\njulia> clique_graph(Int8(10), Int8(4))\n{40, 184} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.complete_bipartite_graph-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.complete_bipartite_graph","text":"complete_bipartite_graph(n1, n2)\n\nCreate an undirected complete bipartite graph with n1 + n2 vertices.\n\nExamples\n\njulia> complete_bipartite_graph(3, 4)\n{7, 12} undirected simple Int64 graph\n\njulia> complete_bipartite_graph(Int8(3), Int8(4))\n{7, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.complete_digraph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.complete_digraph","text":"complete_digraph(n)\n\nCreate a directed complete graph with n vertices.\n\nExamples\n\njulia> complete_digraph(5)\n{5, 20} directed simple Int64 graph\n\njulia> complete_digraph(Int8(6))\n{6, 30} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.complete_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.complete_graph","text":"complete_graph(n)\n\nCreate an undirected complete graph with n vertices.\n\nExamples\n\njulia> complete_graph(5)\n{5, 10} undirected simple Int64 graph\n\njulia> complete_graph(Int8(6))\n{6, 15} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.complete_multipartite_graph-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.complete_multipartite_graph","text":"complete_multipartite_graph(partitions)\n\nCreate an undirected complete bipartite graph with sum(partitions) vertices. A partition with 0 vertices is skipped.\n\nImplementation Notes\n\nPreserves the eltype of the partitions vector. Will error if the required number of vertices exceeds the eltype.\n\nExamples\n\njulia> complete_multipartite_graph([1,2,3])\n{6, 11} undirected simple Int64 graph\n\njulia> complete_multipartite_graph(Int8[5,5,5])\n{15, 75} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.cycle_digraph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.cycle_digraph","text":"cycle_digraph(n)\n\nCreate a directed cycle graph with n vertices.\n\nExamples\n\njulia> cycle_digraph(3)\n{3, 3} directed simple Int64 graph\n\njulia> cycle_digraph(Int8(5))\n{5, 5} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.cycle_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.cycle_graph","text":"cycle_graph(n)\n\nCreate an undirected cycle graph with n vertices.\n\nExamples\n\njulia> cycle_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> cycle_graph(Int8(5))\n{5, 5} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.double_binary_tree-Tuple{Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.double_binary_tree","text":"double_binary_tree(k::Integer)\n\nCreate a double complete binary tree with k levels.\n\nReferences\n\nUsed as an example for spectral clustering by Guattery and Miller 1998.\n\nExamples\n\njulia> double_binary_tree(4)\n{30, 29} undirected simple Int64 graph\n\njulia> double_binary_tree(Int8(5))\n{62, 61} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.grid-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.grid","text":"grid(dims; periodic=false)\n\nCreate a dims-dimensional cubic lattice, with length dims[i] in dimension i.\n\nOptional Arguments\n\nperiodic=false: If true, the resulting lattice will have periodic boundary\n\ncondition in each dimension.\n\nExamples\n\njulia> grid([2,3])\n{6, 7} undirected simple Int64 graph\n\njulia> grid(Int8[2, 2, 2], periodic=true)\n{8, 12} undirected simple Int8 graph\n\njulia> grid((2,3))\n{6, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.ladder_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.ladder_graph","text":"ladder_graph(n)\n\nCreate a ladder graph consisting of 2n nodes and 3n-2 edges.\n\nImplementation Notes\n\nPreserves the eltype of n. Will error if the required number of vertices exceeds the eltype.\n\nExamples\n\njulia> ladder_graph(3)\n{6, 7} undirected simple Int64 graph\n\njulia> ladder_graph(Int8(4))\n{8, 10} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.lollipop_graph-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.lollipop_graph","text":"lollipop_graph(n1, n2)\n\nCreate a lollipop graph consisting of a clique of size n1 connected by an edge to a path of size n2.\n\nImplementation Notes\n\nPreserves the eltype of n1 and n2. Will error if the required number of vertices exceeds the eltype. n1 and n2 must be at least 1 so that both the clique and the path have at least one vertex. The graph is organized with nodes 1:n1 being the clique and n1+1:n1+n2 being the path. The clique is connected to the path by an edge (n1, n1+1).\n\nExamples\n\njulia> lollipop_graph(2, 5)\n{7, 6} undirected simple Int64 graph\n\njulia> lollipop_graph(Int8(3), Int8(4))\n{7, 7} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.path_digraph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.path_digraph","text":"path_digraph(n)\n\nCreates a directed path graph with n vertices.\n\nExamples\n\njulia> path_digraph(5)\n{5, 4} directed simple Int64 graph\n\njulia> path_digraph(Int8(10))\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.path_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.path_graph","text":"path_graph(n)\n\nCreate an undirected path graph with n vertices.\n\nExamples\n\njulia> path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> path_graph(Int8(10))\n{10, 9} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.roach_graph-Tuple{Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.roach_graph","text":"roach_graph(k)\n\nCreate a Roach graph of size k.\n\nReferences\n\nGuattery and Miller 1998\n\nExamples\n\njulia> roach_graph(10)\n{40, 48} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.star_digraph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.star_digraph","text":"star_digraph(n)\n\nCreate a directed star graph with n vertices.\n\nExamples\n\njulia> star_digraph(3)\n{3, 2} directed simple Int64 graph\n\njulia> star_digraph(Int8(10))\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.star_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.star_graph","text":"star_graph(n)\n\nCreate an undirected star graph with n vertices.\n\nExamples\n\njulia> star_graph(3)\n{3, 2} undirected simple Int64 graph\n\njulia> star_graph(Int8(10))\n{10, 9} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.turan_graph-Tuple{Integer,Integer}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.turan_graph","text":"turan_graph(n, r)\n\nCreates a Turán Graph, a complete multipartite graph with n vertices and r partitions.\n\nExamples\n\njulia> turan_graph(6, 2)\n{6, 9} undirected simple Int64 graph\n\njulia> turan_graph(Int8(7), 2)\n{7, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.wheel_digraph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.wheel_digraph","text":"wheel_digraph(n)\n\nCreate a directed wheel graph with n vertices.\n\nExamples\n\njulia> wheel_digraph(5)\n{5, 8} directed simple Int64 graph\n\njulia> wheel_digraph(Int8(6))\n{6, 10} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.wheel_graph-Union{Tuple{T}, Tuple{T}} where T<:Integer","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.wheel_graph","text":"wheel_graph(n)\n\nCreate an undirected wheel graph with n vertices.\n\nExamples\n\njulia> wheel_graph(5)\n{5, 8} undirected simple Int64 graph\n\njulia> wheel_graph(Int8(6))\n{6, 10} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.smallgraph-Tuple{Symbol}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.smallgraph","text":"smallgraph(s)\nsmallgraph(s)\n\nCreate a small graph of type s. Admissible values for s are:\n\ns graph type\n:bull A bull graph.\n:chvatal A Chvátal graph.\n:cubical A Platonic cubical graph.\n:desargues A Desarguesgraph.\n:diamond A diamond graph.\n:dodecahedral A Platonic dodecahedral  graph.\n:frucht A Frucht graph.\n:heawood A Heawood graph.\n:house A graph mimicing the classic outline of a house.\n:housex A house graph, with two edges crossing the bottom square.\n:icosahedral A Platonic icosahedral   graph.\n:karate A social network graph called Zachary's karate club.\n:krackhardtkite A Krackhardt-Kite social network  graph.\n:moebiuskantor A Möbius-Kantor graph.\n:octahedral A Platonic octahedral graph.\n:pappus A Pappus graph.\n:petersen A Petersen graph.\n:sedgewickmaze A simple maze graph used in Sedgewick's Algorithms in C++: Graph  Algorithms (3rd ed.)\n:tetrahedral A Platonic tetrahedral  graph.\n:truncatedcube A skeleton of the truncated cube graph.\n:truncatedtetrahedron A skeleton of the truncated tetrahedron  graph.\n:truncatedtetrahedron_dir A skeleton of the truncated tetrahedron digraph.\n:tutte A Tutte graph.\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Array{T,2} where T}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.euclidean_graph","text":"euclidean_graph(points)\n\nGiven the d×N matrix points build an Euclidean graph of N vertices and return a graph and Dict containing the distance on each edge.\n\nOptional Arguments\n\nL=1: used to bound the d dimensional box from which points are selected.\np=2\nbc=:open\n\nImplementation Notes\n\nDefining the d-dimensional vectors x[i] = points[:,i], an edge between vertices i and j is inserted if norm(x[i]-x[j], p) < cutoff. In case of negative cutoff instead every edge is inserted. For p=2 we have the standard Euclidean distance. Set bc=:periodic to impose periodic boundary conditions in the box 0L^d.\n\nExamples\n\njulia> pts = rand(3, 10); # 10 vertices in R^3\n\njulia> g, dists = euclidean_graph(pts, p=1, bc=:periodic) # Taxicab-distance (L^1);\n\njulia> g\n{10, 45} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"generators/#LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Int64,Int64}","page":"Making and Modifying Graphs","title":"LightGraphs.SimpleGraphs.euclidean_graph","text":"euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)\n\nGenerate N uniformly distributed points in the box 0L^d and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.\n\nExamples\n\njulia> g, dists = euclidean_graph(5, 2, cutoff=0.3);\n\njulia> g\n{5, 4} undirected simple Int64 graph\n\njulia> dists\nDict{LightGraphs.SimpleGraphs.SimpleEdge{Int64},Float64} with 4 entries:\n  Edge 1 => 5 => 0.205756\n  Edge 2 => 5 => 0.271359\n  Edge 2 => 4 => 0.247703\n  Edge 4 => 5 => 0.168372\n\n\n\n\n\n","category":"method"},{"location":"matching/#Matching-1","page":"Matching","title":"Matching","text":"","category":"section"},{"location":"matching/#","page":"Matching","title":"Matching","text":"Maximum weight matching is supported in the companion package LightGraphsMatching.jl.","category":"page"},{"location":"centrality/#Centrality-Measures-1","page":"Centrality Measures","title":"Centrality Measures","text":"","category":"section"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Centrality measures describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in LightGraphs.jl include the following:","category":"page"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Pages   = [\"centrality.md\"]","category":"page"},{"location":"centrality/#Full-docs-1","page":"Centrality Measures","title":"Full docs","text":"","category":"section"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Modules = [LightGraphs]\nPages   = [\n    \"centrality/betweenness.jl\",\n    \"centrality/closeness.jl\",\n    \"centrality/degree.jl\",\n    \"centrality/eigenvector.jl\",\n    \"centrality/katz.jl\",\n    \"centrality/pagerank.jl\",\n    \"centrality/stress.jl\",\n    \"centrality/radiality.jl\"\n]\nPrivate = false","category":"page"},{"location":"graphtypes/#Graph-Types-1","page":"Choosing A Graph Type","title":"Graph Types","text":"","category":"section"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"In addition to providing SimpleGraph and SimpleDiGraph implementations, LightGraphs also serves as a framework for other graph types. Currently, there are several alternative graph types, each with its own package:","category":"page"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"SimpleWeightedGraphs provides a structure for (un)directed graphs with the ability to specify weights on edges.\nMetaGraphs provides a structure (un)directed graphs that supports user-defined properties on the graph, vertices, and edges.\nStaticGraphs supports very large graph structures in a space- and time-efficient manner, but as the name implies, does not allow modification of the graph once created.","category":"page"},{"location":"graphtypes/#Which-Graph-Type-Should-I-Use?-1","page":"Choosing A Graph Type","title":"Which Graph Type Should I Use?","text":"","category":"section"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"These are general guidelines to help you select the proper graph type.","category":"page"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"In general, prefer the native SimpleGraphs/SimpleDiGraphs structures in LightGraphs.jl.\nIf you need edge weights and don't require large numbers of graph modifications, use SimpleWeightedGraphs.\nIf you need labeling of vertices or edges, use MetaGraphs.\nIf you work with very large graphs (billons to tens of billions of edges) and don't need mutability, use StaticGraphs.","category":"page"},{"location":"developing/#Developing-Alternate-Graph-Types-1","page":"Developer Notes","title":"Developing Alternate Graph Types","text":"","category":"section"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"This section is designed to guide developers who wish to write their own graph structures.","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"All LightGraphs functions rely on a standard API to function. As long as your graph structure is a subtype of AbstractGraph and implements the following API functions with the given return values, all functions within the LightGraphs package should just work:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"edges\nBase.eltype\nedgetype (example: edgetype(g::CustomGraph) = LightGraphs.SimpleEdge{eltype(g)}))\nhas_edge\nhas_vertex\ninneighbors\nne\nnv\noutneighbors\nvertices\nis_directed: Note that since LightGraphs uses traits to determine directedness, is_directed for a CustomGraph type","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"should be implemented with both of the following signatures:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"is_directed(::Type{CustomGraph})::Bool (example: is_directed(::Type{<:CustomGraph}) = false)\nis_directed(g::CustomGraph)::Bool\nzero","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"If the graph structure is designed to represent weights on edges, the weights function should also be defined. Note that the output does not necessarily have to be a dense matrix, but it must be a subtype of AbstractMatrix{<:Real} and indexable via [u, v].","category":"page"},{"location":"developing/#Note-on-inheriting-from-AbstractSimpleGraph-1","page":"Developer Notes","title":"Note on inheriting from AbstractSimpleGraph","text":"","category":"section"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"Every subtype of AbstractSimpleGraph must return neighbors in ascending order.","category":"page"},{"location":"core/#Core-Functions-1","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"LightGraphs.jl includes the following core functions:","category":"page"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"Order = [:type, :function]\nPages   = [\"core.md\"]","category":"page"},{"location":"core/#Full-Docs-1","page":"Core Functions","title":"Full Docs","text":"","category":"section"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"Modules = [LightGraphs]\nPages   = [ \"core.jl\"]\nPrivate = false","category":"page"},{"location":"core/#LightGraphs.add_vertices!-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.add_vertices!","text":"add_vertices!(g, n)\n\nAdd n new vertices to the graph g. Return the number of vertices that were added successfully.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph()\n{0, 0} undirected simple Int64 graph\n\njulia> add_vertices!(g, 2)\n2\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.all_neighbors","page":"Core Functions","title":"LightGraphs.all_neighbors","text":"all_neighbors(g, v)\n\nReturn a list of all inbound and outbound neighbors of v in g. For undirected graphs, this is equivalent to both outneighbors and inneighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\n```jldoctest julia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> all_neighbors(g, 1) 1-element Array{Int64,1}:  3\n\njulia> all_neighbors(g, 2) 1-element Array{Int64,1}:  3\n\njulia> all_neighbors(g, 3) 2-element Array{Int64,1}:  1  2  ```\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.common_neighbors-Tuple{AbstractGraph,Integer,Integer}","page":"Core Functions","title":"LightGraphs.common_neighbors","text":"common_neighbors(g, u, v)\n\nReturn the neighbors common to vertices u and v in g.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(4);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> add_edge!(g, 4, 1);\n\njulia> add_edge!(g, 1, 3);\n\njulia> common_neighbors(g, 1, 3)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> common_neighbors(g, 1, 4)\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.degree","page":"Core Functions","title":"LightGraphs.degree","text":"degree(g[, v])\n\nReturn a vector corresponding to the number of edges which start or end at each vertex in graph g. If v is specified, only return degrees for vertices in v. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> degree(g)\n3-element Array{Int64,1}:\n 1\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T},Any}} where T","page":"Core Functions","title":"LightGraphs.degree_histogram","text":"degree_histogram(g, degfn=degree)\n\nReturn a Dict with values representing the number of vertices that have degree represented by the key.\n\nDegree function (for example, indegree or outdegree) may be specified by overriding degfn.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.density","page":"Core Functions","title":"LightGraphs.density","text":"density(g)\n\nReturn the density of g. Density is defined as the ratio of the number of actual edges to the number of possible edges (V(V-1) for directed graphs and fracV(V-1)2 for undirected graphs).\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.has_self_loops-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.has_self_loops","text":"has_self_loops(g)\n\nReturn true if g has any self loops.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_self_loops(g)\nfalse\n\njulia> add_edge!(g, 1, 1);\n\njulia> has_self_loops(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.indegree-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.indegree","text":"indegree(g[, v])\n\nReturn a vector corresponding to the number of edges which end at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> indegree(g)\n3-element Array{Int64,1}:\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.is_ordered-Tuple{AbstractEdge}","page":"Core Functions","title":"LightGraphs.is_ordered","text":"is_ordered(e)\n\nReturn true if the source vertex of edge e is less than or equal to the destination vertex.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(2);\n\njulia> add_edge!(g, 2, 1);\n\njulia> is_ordered(first(edges(g)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.neighbors-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.neighbors","text":"neighbors(g, v)\n\nReturn a list of all neighbors reachable from vertex v in g. For directed graphs, the default is equivalent to outneighbors; use all_neighbors to list inbound and outbound neighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> neighbors(g, 1)\n0-element Array{Int64,1}\n\njulia> neighbors(g, 2)\n1-element Array{Int64,1}:\n 3\n\njulia> neighbors(g, 3)\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.num_self_loops-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.num_self_loops","text":"num_self_loops(g)\n\nReturn the number of self loops in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> num_self_loops(g)\n0\n\njulia> add_edge!(g, 1, 1);\n\njulia> num_self_loops(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.outdegree-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.outdegree","text":"outdegree(g[, v])\n\nReturn a vector corresponding to the number of edges which start at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> outdegree(g)\n3-element Array{Int64,1}:\n 0\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.squash-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.squash","text":"squash(g)\n\nReturn a copy of a graph with the smallest practical type that can accommodate all vertices.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.weights-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.weights","text":"weights(g)\n\nReturn the weights of the edges of a graph g as a matrix. Defaults to LightGraphs.DefaultDistance.\n\nImplementation Notes\n\nIn general, referencing the weight of a nonexistent edge is undefined behavior. Do not rely on the weights matrix as a substitute for the graph's adjacency_matrix.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δ-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δ","text":"Δ(g)\n\nReturn the maximum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δin-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δin","text":"Δin(g)\n\nReturn the maximum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δout-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δout","text":"Δout(g)\n\nReturn the maximum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δ-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δ","text":"δ(g)\n\nReturn the minimum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δin-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δin","text":"δin(g)\n\nReturn the minimum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δout-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δout","text":"δout(g)\n\nReturn the minimum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"degeneracy/#Graph-Decomposition-1","page":"Degeneracy","title":"Graph Decomposition","text":"","category":"section"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"LightGraphs.jl provides the following graph degeneracy functions:","category":"page"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"Order = [:type, :function]\nPages   = [\"degeneracy.md\"]","category":"page"},{"location":"degeneracy/#Full-Docs-1","page":"Degeneracy","title":"Full Docs","text":"","category":"section"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"Modules = [LightGraphs]\nPages   = [\"degeneracy.jl\"]\nPrivate = false","category":"page"},{"location":"degeneracy/#LightGraphs.core_number-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T","page":"Degeneracy","title":"LightGraphs.core_number","text":"core_number(g)\n\nReturn the core number for each vertex in graph g.\n\nA k-core is a maximal subgraph that contains vertices of degree k or more. The core number of a vertex is the largest value k of a k-core containing that vertex.\n\nImplementation Notes\n\nNot implemented for graphs with self loops.\n\nReferences\n\nAn O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> core_number(g)\n6-element Array{Int64,1}:\n 1\n 2\n 2\n 2\n 2\n 0\n\n\n\n\n\n","category":"method"},{"location":"degeneracy/#LightGraphs.k_core","page":"Degeneracy","title":"LightGraphs.k_core","text":"k_core(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-core of graph g. If k is not specified, return the core with the largest degree.\n\nA k-core is a maximal subgraph that contains vertices of degree k or more.\n\nImplementation Notes\n\nNot implemented for graphs with self loops.\n\nReferences\n\nAn O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_core(g, 1)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> k_core(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"degeneracy/#LightGraphs.k_corona-Tuple{AbstractGraph,Any}","page":"Degeneracy","title":"LightGraphs.k_corona","text":"k_corona(g, k; corenum=core_number(g))\n\nReturn a vector of vertices in the k-corona of g.\n\nThe k-corona is the subgraph of vertices in the k-core which have exactly k neighbors in the k-core.\n\nImplementation Notes\n\nNot implemented for graphs with parallel edges or self loops.\n\nReferences\n\nk-core (bootstrap) percolation on complex networks:  Critical phenomena and nonlocal effects,  A. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,  Phys. Rev. E 73, 056101 (2006)  http://link.aps.org/doi/10.1103/PhysRevE.73.056101\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_corona(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_corona(g, 1)\n1-element Array{Int64,1}:\n 1\n\njulia> k_corona(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\njulia> k_corona(g, 3)\n0-element Array{Int64,1}\n\n\n\n\n\n","category":"method"},{"location":"degeneracy/#LightGraphs.k_crust","page":"Degeneracy","title":"LightGraphs.k_crust","text":"k_crust(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-crust of g. If k is not specified, return the crust of the core with the largest degree.\n\nThe k-crust is the graph g with the k-core removed.\n\nImplementation Notes\n\nThis definition of k-crust is different than the definition in References. The k-crust in References is equivalent to the k+1 crust of this algorithm.\n\nNot implemented for graphs with self loops.\n\nReferences\n\nA model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_crust(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_crust(g, 1)\n2-element Array{Int64,1}:\n 1\n 6\n\njulia> k_crust(g, 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"degeneracy/#LightGraphs.k_shell","page":"Degeneracy","title":"LightGraphs.k_shell","text":"k_shell(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-shell of g. If k is not specified, return the shell of the core with the largest degree.\n\nThe k-shell is the subgraph of vertices in the k-core but not in the (k+1)-core. This is similar to k_corona but in that case only neighbors in the k-core are considered.\n\nImplementation Notes\n\nNot implemented for graphs with parallel edges or self loops.\n\nReferences\n\nA model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_shell(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_shell(g, 1)\n1-element Array{Int64,1}:\n 1\n\njulia> k_shell(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"coloring/#Coloring-1","page":"Coloring","title":"Coloring","text":"","category":"section"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"LightGraphs.jl defines a structure and basic interface for coloring algorithms. Since coloring is a hard problem in the general case, users can extend the behavior and define their own function taking a graph as input and returning the Coloring structure.","category":"page"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"Order = [:type, :function]\nPages = [\"coloring.md\"]","category":"page"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"Modules = [LightGraphs]\nPages   = [\n    \"traversals/greedy_color.jl\",\n]","category":"page"},{"location":"errorhandling/#Error-Handling-1","page":"-","title":"Error Handling","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"In an ideal world, all software would work perfectly all the time. However, in the real world software encounters errors due to the outside world, bad input, bugs, or programmer error.","category":"page"},{"location":"errorhandling/#Types-of-Errors-1","page":"-","title":"Types of Errors","text":"","category":"section"},{"location":"errorhandling/#Sentinel-Values-1","page":"-","title":"Sentinel Values","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"It is the position of this project that error conditions that happen often, typically due to bad data should be handled with sentinel values returned to indicate the failure condition. These are used for functions such as add_edge!(g, u, v). If you try to add an edge with negative vertex numbers, or vertices that exceed the number of vertices in the graph, then you will get a return value of false.","category":"page"},{"location":"errorhandling/#Errors-/-Exceptions-1","page":"-","title":"Errors / Exceptions","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"For more severe failures such as bad arguments or failure to converge, we use exceptions. The primary distinction between Sentinel Values and Argument Errors has to do with the run time of the function being called. In a function that is expected to be a called in a tight loop such as add_edge!, we will use a sentinel value rather than an exception. This is because it is faster to do a simple if statement to handle the error than a full try/catch block. For functions that take longer to run, we use Exceptions. If you find an exception with an error message that isn't helpful for debugging, please file a bug report so that we can improve these messages.","category":"page"},{"location":"errorhandling/#","page":"-","title":"-","text":"ArgumentError: the inputs to this function are not valid\nInexactError: there are types that cannot express something with the necessary precision","category":"page"},{"location":"basicproperties/#Accessing-Graph-Properties-1","page":"Accessing Properties","title":"Accessing Graph Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"The following is an overview of functions for accessing graph properties. For functions that modify graphs, see Making and Modifying Graphs.","category":"page"},{"location":"basicproperties/#Graph-Properties:-1","page":"Accessing Properties","title":"Graph Properties:","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"nv: Returns number of vertices in graph.\nne: Returns number of edges in graph.\nvertices: Iterable object of all graph vertices.\nedges: Iterable object of all graph edges.\nhas_vertex: Checks for whether graph includes a vertex.\nhas_edge(g, s, d): Checks for whether graph includes an edge from a given source s to a given destination d.\nhas_edge(g, e) will return true if there is an edge in g that satisfies e == f for any f ∈ edges(g). This is a strict equality test that may require all properties of e are the same. This definition of equality depends on the implementation. For testing whether an edge exists between two vertices s,d use has_edge(g, s, d).","category":"page"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"Note: to use the has_edge(g, e) method safely, it is important to understand the conditions under which edges are equal to each other. These conditions are defined by the has_edge(g::G,e) method as defined by the graph type G. The default behavior is to check has_edge(g,src(e),dst(e)). This distinction exists to allow new graph types such as MetaGraphs or MultiGraphs to distinguish between edges with the same source and destination but potentially different properties.","category":"page"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"has_self_loops Checks for self-loops.\nis_directed Checks if graph is directed.\neltype Returns element type of graphs.","category":"page"},{"location":"basicproperties/#Vertex-Properties-1","page":"Accessing Properties","title":"Vertex Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"neighbors: Return array of neighbors of a vertex. If graph is directed, output is equivalent of outneighbors.\nall_neighbors:  Returns array of all neighbors (both inneighbors and outneighbors). For undirected graphs, equivalent to neighbors.\ninneighbors: Return array of in-neighbors. Equivalent to neighbors for undirected graphs.\noutneighbors: Return array of out-neighbors. Equivalent to neighbors for undirected graphs.","category":"page"},{"location":"basicproperties/#Edge-Properties-1","page":"Accessing Properties","title":"Edge Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"src: Give source vertex of an edge.\ndst: Give destination vertex of an edge.\nreverse: Creates a new edge running in opposite direction of passed edge.","category":"page"},{"location":"community/#Community-Structures-1","page":"Community Structures","title":"Community Structures","text":"","category":"section"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"LightGraphs.jl contains many algorithm to detect and analyze community structures in graphs. These include:","category":"page"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"Order = [:type, :function]\nPages   = [\"community.md\"]","category":"page"},{"location":"community/#Full-Docs-1","page":"Community Structures","title":"Full Docs","text":"","category":"section"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"Modules = [LightGraphs]\nPages   = [\n    \"community/cliques.jl\",\n    \"community/clustering.jl\",\n    \"community/core-periphery.jl\",\n    \"community/label_propagation.jl\",\n    \"community/modularity.jl\"\n]\nPrivate = false","category":"page"},{"location":"integration/#Integration-with-other-packages-1","page":"Integration with other packages","title":"Integration with other packages","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"LightGraphs.jl's integration with other Julia packages is designed to be straightforward. Here are a few examples.","category":"page"},{"location":"integration/#[Graphs.jl](http://github.com/JuliaLang/Graphs.jl)-1","page":"Integration with other packages","title":"Graphs.jl","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"Creating a Graphs.jl simple_graph is easy:","category":"page"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"julia> s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia> for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end","category":"page"},{"location":"integration/#[Metis.jl](https://github.com/JuliaSparse/Metis.jl)-1","page":"Integration with other packages","title":"Metis.jl","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"The Metis graph partitioning package can interface with LightGraphs.jl:","category":"page"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"julia> using LightGraphs\n\njulia> g = SimpleGraph(100,1000)\n{100, 1000} undirected graph\n\njulia> partGraphKway(g, 6)  # 6 partitions","category":"page"},{"location":"experimental/#Experimental-Graph-Algorithms-1","page":"Experimental Functionality","title":"Experimental Graph Algorithms","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"LightGraphs.Experimental is a module for graph algorithms that are newer or less stable. We can adopt algorithms before we finalize an interface for using them or if we feel that full support cannot be provided to the current implementation. You can expect new developments to land here before they make it into the main module. This enables the development to keep advancing without being risk averse because of stability guarantees. You can think of this module as a 0.X semantic version space; it is a place where you can play around with new algorithms, perspectives, and interfaces without fear of breaking critical code.","category":"page"},{"location":"experimental/#A-Note-To-Users-1","page":"Experimental Functionality","title":"A Note To Users","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Code in this module is unstable and subject to change. Do not use any code in this module in production environments without understanding the (large) risks involved. However, we welcome bug reports and issues via the normal channels..","category":"page"},{"location":"experimental/#Graph-Isomorphism-1","page":"Experimental Functionality","title":"Graph Isomorphism","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Here is the documentation for graph isomorphism functions.","category":"page"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Modules = [LightGraphs]\nPages   = [\n    \"Experimental/isomorphism.jl\",\n]\nPrivate = false","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (c) 2015: Seth Bromberger and other contributors.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"LightGraphs uses code derived from and/or inspired by the following packages:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"NetworkX:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (C) 2004-2012, NetworkX Developers Aric Hagberg <hagberg@lanl.gov> Dan Schult <dschult@colgate.edu> Pieter Swart <swart@lanl.gov> All rights reserved.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above with the distribution.\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Graphs.jl:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (c) 2012: John Myles White and other contributors.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"OpenStreetMapX.jl:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"MIT LicensePermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"operators/#Operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/#","page":"Operators","title":"Operators","text":"LightGraphs.jl implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both SimpleGraph or both SimpleDiGraph).","category":"page"},{"location":"operators/#","page":"Operators","title":"Operators","text":"Order = [:type, :function]\nPages   = [\"operators.md\"]","category":"page"},{"location":"operators/#Full-Docs-1","page":"Operators","title":"Full Docs","text":"","category":"section"},{"location":"operators/#","page":"Operators","title":"Operators","text":"Modules = [LightGraphs]\nPages   = [\"operators.jl\"]\nPrivate = false","category":"page"},{"location":"operators/#Base.intersect-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractGraph","page":"Operators","title":"Base.intersect","text":"intersect(g, h)\n\nReturn a graph with edges that are only in both graph g and graph h.\n\nImplementation Notes\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(intersect(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.join-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractGraph","page":"Operators","title":"Base.join","text":"join(g, h)\n\nReturn a graph that combines graphs g and h using blockdiag and then adds all the edges between the vertices in g and those in h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = join(star_graph(3), path_graph(2))\n{5, 9} undirected simple Int64 graph\n\njulia> collect(edges(g))\n9-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n Edge 2 => 4\n Edge 2 => 5\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.reverse","page":"Operators","title":"Base.reverse","text":"reverse(g)\n\nReturn a directed graph where all edges are reversed from the original directed graph.\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(reverse(g)))\nEdge 1 => 3\nEdge 2 => 1\nEdge 3 => 2\nEdge 4 => 3\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"function"},{"location":"operators/#Base.reverse!","page":"Operators","title":"Base.reverse!","text":"reverse!(g)\n\nIn-place reverse of a directed graph (modifies the original graph). See reverse for a non-modifying version.\n\n\n\n\n\n","category":"function"},{"location":"operators/#Base.union-Union{Tuple{T}, Tuple{T,T}} where T<:LightGraphs.SimpleGraphs.AbstractSimpleGraph","page":"Operators","title":"Base.union","text":"union(g, h)\n\nReturn a graph that combines graphs g and h by taking the set union of all vertices and edges.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(5);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(h, 3, 4);\n\njulia> add_edge!(h, 3, 5);\n\njulia> add_edge!(h, 4, 5);\n\njulia> f = union(g, h);\n\njulia> collect(edges(f))\n5-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.cartesian_product-Union{Tuple{G}, Tuple{G,G}} where G<:AbstractGraph","page":"Operators","title":"LightGraphs.cartesian_product","text":"cartesian_product(g, h)\n\nReturn the cartesian product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = cartesian_product(star_graph(3), path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 1 => 7\n Edge 2 => 3\n Edge 2 => 5\n Edge 2 => 8\n Edge 3 => 6\n Edge 3 => 9\n Edge 4 => 5\n Edge 5 => 6\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.complement-Tuple{SimpleGraph}","page":"Operators","title":"LightGraphs.complement","text":"complement(g)\n\nReturn the graph complement of a graph\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(complement(g)))\nEdge 1 => 3\nEdge 1 => 4\nEdge 1 => 5\nEdge 2 => 1\nEdge 2 => 4\nEdge 2 => 5\nEdge 3 => 2\nEdge 3 => 5\nEdge 4 => 1\nEdge 4 => 2\nEdge 4 => 3\nEdge 5 => 1\nEdge 5 => 2\nEdge 5 => 3\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.crosspath","page":"Operators","title":"LightGraphs.crosspath","text":"crosspath(len::Integer, g::Graph)\n\nReturn a graph that duplicates g len times and connects each vertex with its copies in a path.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = crosspath(3, path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 5\n Edge 3 => 6\n Edge 4 => 5\n Edge 4 => 7\n Edge 5 => 6\n Edge 5 => 8\n Edge 6 => 9\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"function"},{"location":"operators/#LightGraphs.difference-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractGraph","page":"Operators","title":"LightGraphs.difference","text":"difference(g, h)\n\nReturn a graph with edges in graph g that are not in graph h.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(difference(g1, g2)))\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.egonet-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T},Integer,Integer}, Tuple{AbstractGraph{T},Integer,Integer,AbstractArray{U,2}}} where T<:Integer where U<:Real","page":"Operators","title":"LightGraphs.egonet","text":"egonet(g, v, d, distmx=weights(g))\n\nReturn the subgraph of g induced by the neighbors of v up to distance d, using weights (optionally) provided by distmx. This is equivalent to induced_subgraph(g, neighborhood(g, v, d, dir=dir))[1].\n\nOptional Arguments\n\ndir=:out: if g is directed, this argument specifies the edge direction\n\nwith respect to v (i.e. :in or :out).\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T,AbstractArray{U,1}}} where T<:AbstractGraph where U<:Integer","page":"Operators","title":"LightGraphs.induced_subgraph","text":"induced_subgraph(g, vlist)\ninduced_subgraph(g, elist)\n\nReturn the subgraph of g induced by the vertices in  vlist or edges in elist along with a vector mapping the new vertices to the old ones (the  vertex i in the subgraph corresponds to the vertex vmap[i] in g.)\n\nThe returned graph has length(vlist) vertices, with the new vertex i corresponding to the vertex of the original graph in the i-th position of vlist.\n\nUsage Examples\n\njulia> g = complete_graph(10)\n\njulia> sg, vmap = induced_subgraph(g, 5:8)\n\njulia> @assert g[5:8] == sg\n\njulia> @assert nv(sg) == 4\n\njulia> @assert ne(sg) == 6\n\njulia> @assert vm[4] == 8\n\njulia> sg, vmap = induced_subgraph(g, [2,8,3,4])\n\njulia> @assert sg == g[[2,8,3,4]]\n\njulia> elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia> sg, vmap = induced_subgraph(g, elist)\n\njulia> @assert sg == g[elist]\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.merge_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T},Array{U,1} where U<:Integer}} where T","page":"Operators","title":"LightGraphs.merge_vertices!","text":"merge_vertices!(g, vs)\n\nCombine vertices specified in vs into single vertex whose index will be the lowest value in vs. All edges connected to vertices in vs connect to the new merged vertex.\n\nReturn a vector with new vertex values are indexed by the original vertex indices.\n\nImplementation Notes\n\nSupports SimpleGraph only.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> merge_vertices!(g, [2, 3])\n5-element Array{Int64,1}:\n 1\n 2\n 2\n 3\n 4\n\njulia> collect(edges(g))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.merge_vertices-Tuple{AbstractGraph,Any}","page":"Operators","title":"LightGraphs.merge_vertices","text":"merge_vertices(g::AbstractGraph, vs)\n\nCreate a new graph where all vertices in vs have been aliased to the same vertex minimum(vs).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> h = merge_vertices(g, [2, 3]);\n\njulia> collect(edges(h))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.symmetric_difference-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractGraph","page":"Operators","title":"LightGraphs.symmetric_difference","text":"symmetric_difference(g, h)\n\nReturn a graph with edges from graph g that do not exist in graph h, and vice versa.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(h, 1, 3);\n\njulia> add_edge!(h, 2, 3);\n\njulia> f = symmetric_difference(g, h);\n\njulia> collect(edges(f))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.tensor_product-Union{Tuple{G}, Tuple{G,G}} where G<:AbstractGraph","page":"Operators","title":"LightGraphs.tensor_product","text":"tensor_product(g, h)\n\nReturn the tensor product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = tensor_product(star_graph(3), path_graph(3))\n{9, 8} undirected simple Int64 graph\n\njulia> collect(edges(g))\n8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 5\n Edge 1 => 8\n Edge 2 => 4\n Edge 2 => 6\n Edge 2 => 7\n Edge 2 => 9\n Edge 3 => 5\n Edge 3 => 8\n\n\n\n\n\n","category":"method"},{"location":"operators/#SparseArrays.blockdiag-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractGraph","page":"Operators","title":"SparseArrays.blockdiag","text":"blockdiag(g, h)\n\nReturn a graph with V(g) + V(h) vertices and E(g) + E(h) edges where the vertices and edges from graph h are appended to graph g.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> blockdiag(g1, g2)\n{8, 9} directed simple Int64 graph\n\njulia> foreach(println, edges(blockdiag(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\nEdge 6 => 7\nEdge 7 => 8\nEdge 8 => 6\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting-Graphs-1","page":"Plotting Graphs","title":"Plotting Graphs","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"LightGraphs.jl integrates with several other Julia packages for plotting. Here are a few examples.","category":"page"},{"location":"plotting/#[GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)-1","page":"Plotting Graphs","title":"GraphLayout.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"This excellent graph visualization package can be used with LightGraphs.jl as follows:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> g = wheel_graph(10); am = Matrix(adjacency_matrix(g))\njulia> loc_x, loc_y = layout_spring_adj(am)\njulia> draw_layout_adj(am, loc_x, loc_y, filename=\"wheel10.svg\")","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"producing a graph like this:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: Wheel Graph)","category":"page"},{"location":"plotting/#[TikzGraphs.jl](https://github.com/sisl/TikzGraphs.jl)-1","page":"Plotting Graphs","title":"TikzGraphs.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"Another nice graph visualization package. (TikzPictures.jl required to render/save):","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> g = wheel_graph(10); t = plot(g)\n\njulia> save(SVG(\"wheel10.svg\"), t)","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"producing a graph like this:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: Wheel Graph)","category":"page"},{"location":"plotting/#[GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)-1","page":"Plotting Graphs","title":"GraphPlot.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"Another graph visualization package that is very simple to use. Compose.jl is required for most rendering functionality:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> using GraphPlot, Compose\n\njulia> g = wheel_graph(10)\n\njulia> draw(PNG(\"/tmp/wheel10.png\", 16cm, 16cm), gplot(g))","category":"page"},{"location":"plotting/#[NetworkViz.jl](https://github.com/abhijithanilkumar/NetworkViz.jl)-1","page":"Plotting Graphs","title":"NetworkViz.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl.","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \"widgets\")\n  push!(window.assets,(\"ThreeJS\",\"threejs\"))\n  g = complete_graph(10)\n  drawGraph(g)\nend","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"The above code produces the following output:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: alt tag)","category":"page"},{"location":"#LightGraphs-1","page":"Getting Started","title":"LightGraphs","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The goal of LightGraphs.jl is to offer a performant platform for network and graph analysis in Julia. To this end, LightGraphs offers both (a) a set of simple, concrete graph implementations – SimpleGraph (for undirected graphs) and SimpleDiGraph (for directed graphs), and (b) an API for the development of more sophisticated graph implementations under the AbstractGraph type.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"As such, LightGraphs.jl is the central package of the JuliaGraphs ecosystem. Additional functionality like advanced IO and file formats, weighted graphs, property graphs, and optimization related functions can be found in the following packages:","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"LightGraphsExtras.jl: extra functions for graph analysis.\nMetaGraphs.jl: graphs with associated meta-data.\nSimpleWeightedGraphs.jl: weighted graphs.\nGraphIO.jl: tools for importing and exporting graph objects using common file types like edgelists, GraphML, Pajek NET, and more.\nGraphDataFrameBridge.jl: Tools for converting edgelists stored in DataFrames into graphs (MetaGraphs, MetaDiGraphs).","category":"page"},{"location":"#Basic-library-examples-1","page":"Getting Started","title":"Basic library examples","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The LightGraphs.jl libraries includes numerous convenience functions for generating functions detailed in Making and Modifying Graphs, such as path_graph, which makes a simple undirected path graph of a given length. Once created, these graphs can be easily interrogated and modified.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"julia> g = path_graph(6)\n\n# Number of vertices\njulia> nv(g)\n\n# Number of edges\njulia> ne(g)\n\n# Add an edge to make the path a loop\njulia> add_edge!(g, 1, 6)","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"For an overview of basic functions for interacting with graphs, check out Accessing Graph Properties and Making and Modifying Graphs. Detailed tutorials may be found in the JuliaGraphs Tutorial Notebooks repository.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"We encourage you to cite our work if you have used our libraries, tools or datasets. Starring the repository on GitHub is also appreciated.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"The latest citation information may be found in the CITATION.bib file within the LightGraphs repository.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"For previous versions, please reference the zenodo site.","category":"page"},{"location":"types/#LightGraphs-Types-1","page":"LightGraphs Types","title":"LightGraphs Types","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl supports both the AbstractGraph type and two concrete simple graph types – SimpleGraph for undirected graphs and SimpleDiGraph for directed graphs – that are subtypes of AbstractGraph.","category":"page"},{"location":"types/#Concrete-Types-1","page":"LightGraphs Types","title":"Concrete Types","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl provides two concrete graph types: SimpleGraph is an undirected graph, and SimpleDiGraph is its directed counterpart. Both of these types can be parameterized to specifying how vertices are identified (by default, SimpleGraph and SimpleDiGraph use the system default integer type, usually Int64).","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"A graph G is described by a set of vertices V and edges E: G = {V, E}. V is an integer range 1:n; E is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields Edge types containing (src<:Integer, dst<:Integer) values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Graphs are created using SimpleGraph() or SimpleDiGraph(); there are several options (see the tutorials for examples).","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will not raise an error. This event can be detected using the return value of add_edge!.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Note that graphs in which the number of vertices equals or approaches the typemax of the underlying graph element (e.g., a SimpleGraph{UInt8} with 127 vertices) may encounter arithmetic overflow errors in some functions, which should be reported as bugs. To be safe, please ensure that your graph is sized with some spare capacity.","category":"page"},{"location":"types/#AbstractGraph-Type-1","page":"LightGraphs Types","title":"AbstractGraph Type","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl is structured around a few abstract types developers can base their types on. See Developing Alternate Graph Types for the minimal methods to implement.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Order = [:type]\nPages   = [\"types.md\"]","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"To encourage experimentation and development within the JuliaGraphs ecosystem, LightGraphs.jl defines the AbstractGraph type, which is used by libraries like MetaGraphs.jl (for graphs with associated meta-data) and SimpleWeightedGraphs.jl (for weighted graphs). All types that are a subset of AbstractGraph must implement the following functions (most of which are described in more detail in Accessing Graph Properties and Making and Modifying Graphs):","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Order = [:function]\nPages   = [\"types.md\"]","category":"page"},{"location":"types/#Full-Docs-for-AbstractGraph-types-and-functions-1","page":"LightGraphs Types","title":"Full Docs for AbstractGraph types and functions","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Modules = [LightGraphs]\nPages   = [\"interface.jl\"]\nPrivate = false","category":"page"},{"location":"types/#LightGraphs.AbstractEdge","page":"LightGraphs Types","title":"LightGraphs.AbstractEdge","text":"AbstractEdge\n\nAn abstract type representing a single edge between two vertices of a graph.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightGraphs.AbstractEdgeIter","page":"LightGraphs Types","title":"LightGraphs.AbstractEdgeIter","text":"AbstractEdgeIter\n\nAn abstract type representing an edge iterator.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightGraphs.AbstractGraph","page":"LightGraphs Types","title":"LightGraphs.AbstractGraph","text":"AbstractGraph\n\nAn abstract type representing a graph.\n\n\n\n\n\n","category":"type"},{"location":"types/#Base.reverse-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"Base.reverse","text":"reverse(e)\n\nCreate a new edge from e with source and destination vertices reversed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> reverse(first(edges(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.dst-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"LightGraphs.dst","text":"dst(e)\n\nReturn the destination vertex of edge e.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> dst(first(edges(g)))\n2\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.edges-Tuple{Any}","page":"LightGraphs Types","title":"LightGraphs.edges","text":"edges(g)\n\nReturn (an iterator to or collection of) the edges of a graph. For AbstractSimpleGraphs it returns a SimpleEdgeIter. The expressions e in edges(g) and e ∈ edges(ga) evaluate as calls to has_edge.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(3);\n\njulia> collect(edges(g))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.edgetype-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.edgetype","text":"edgetype(g)\n\nReturn the type of graph g's edge\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.has_edge-Tuple{Any,Any,Any}","page":"LightGraphs Types","title":"LightGraphs.has_edge","text":"has_edge(g, s, d)\n\nReturn true if the graph g has an edge from node s to node d.\n\nAn optional has_edge(g, e) can be implemented to check if an edge belongs to a graph, including any data other than source and destination node.\n\ne ∈ edges(g) or e ∈ edges(g) evaluate as calls to has_edge, c.f. edges.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_edge(g, 1, 2)\ntrue\n\njulia> has_edge(g, 2, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.has_vertex-Tuple{Any,Any}","page":"LightGraphs Types","title":"LightGraphs.has_vertex","text":"has_vertex(g, v)\n\nReturn true if v is a vertex of g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> has_vertex(SimpleGraph(2), 1)\ntrue\n\njulia> has_vertex(SimpleGraph(2), 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.inneighbors-Tuple{Any,Any}","page":"LightGraphs Types","title":"LightGraphs.inneighbors","text":"inneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an incoming edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> inneighbors(g, 4)\n2-element Array{Int64,1}:\n 3\n 5\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.is_directed-Union{Tuple{G}, Tuple{G}} where G","page":"LightGraphs Types","title":"LightGraphs.is_directed","text":"is_directed(G)\n\nReturn true if the graph type G is a directed graph; false otherwise. New graph types must implement is_directed(::Type{<:G}). The method can also be called with is_directed(g::G)\n\nExamples\n\njulia> using LightGraphs\n\njulia> is_directed(SimpleGraph(2))\nfalse\n\njulia> is_directed(SimpleGraph)\nfalse\n\njulia> is_directed(SimpleDiGraph(2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.ne-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.ne","text":"ne(g)\n\nReturn the number of edges in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(3);\n\njulia> ne(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.nv-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.nv","text":"nv(g)\n\nReturn the number of vertices in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> nv(SimpleGraph(3))\n3\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.outneighbors-Tuple{Any,Any}","page":"LightGraphs Types","title":"LightGraphs.outneighbors","text":"outneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an outgoing edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> outneighbors(g, 4)\n1-element Array{Int64,1}:\n 5\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.src-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"LightGraphs.src","text":"src(e)\n\nReturn the source vertex of edge e.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> src(first(edges(g)))\n1\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.vertices-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.vertices","text":"vertices(g)\n\nReturn (an iterator to or collection of) the vertices of a graph.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> collect(vertices(SimpleGraph(4)))\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"zero(::Type{<:AbstractGraph})","category":"page"},{"location":"types/#Base.zero-Tuple{Type{#s1} where #s1<:AbstractGraph}","page":"LightGraphs Types","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"method"}]
}
